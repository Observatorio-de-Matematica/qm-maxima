/*
;;  Author Eric Majzoub, Department of Physics and Astronomy
;;  University of Missouri, St. Louis
;;  Copyright (C) 2024 Eric Majzoub

;;  This program is free software; you can redistribute it and/or modify 
;;  it under the terms of the GNU General Public License as published by         
;;  the Free Software Foundation; either version 2 of the License, or            
;;  (at your option) any later version.                                  
                                                                                 
;;  This program is distributed in the hope that it will be useful,              
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of               
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                
;;  GNU General Public License for more details.         

;; Quantum mechanics package for Maxima.
*/

/* load("groups_ehm.mac") $ */
load("qm.lisp") $ /* for complex_number_p(),
I took this from Barton's to_poly code */

/* load the documentation */
load("qm-index.lisp")$

/* Sadly, this won't work using 'load'. */
/* :lisp (defun $complex_number_p (e) (complex-number-p e #'$numberp)) */

/*
disp("###########  qm_ehm.mac   version 0.5, 08 August 2024  ##########") $ 
disp("create vectors:: cvec, rvec, ket, bra")$
disp("vector tools:: dagger, braket, norm, ketp, brap")$
disp("Other tools:: magsqr(c), commutator(X,Y)")$
disp("spin-1/2 state kets:: zp, zm, xp, xm, yp, ym") $
disp("Pauli and spin-1/2 matrices:: sigmax, sigmay, sigmaz, Sz, Sx, Sy") $
disp("spin-1 matrices and z-kets:: Sz1, Sx1, Sy1, zu, zz, zd") $
disp("expectation value and variance:: expect(Op,psi), qm_variance(Op,psi)") $
*/

/******************************/
/* Simplification definitions */
/******************************/
matchdeclare([aa,bb],freeof(%i));
tellsimpafter(%i*aa+%i*bb,%i*(aa+bb));

matchdeclare([x,y],freeof(%i));
matchdeclare([cc],numberp);
tellsimpafter(%e^x*(%e^y+cc),%e^(x+y)+cc*%e^x);
tellsimpafter(%e^x*(cc-%e^y),cc*%e^x-%e^(x+y));

matchdeclare(x,freeof(%i));
tellsimpafter(%e^x+%e^(-x),2*cosh(x));
tellsimpafter(%e^x-%e^(-x),2*sinh(x));
tellsimpafter(sinh(x)/cosh(x),tanh(x));
tellsimpafter(cos(x)+%i*sin(x),%e^(%i*x));
tellsimpafter(cos(x)-%i*sin(x),%e^(-%i*x));

/*******************************/
/* Constants and assumptions   */
/*******************************/
declare(hbar,real) $
assume(hbar>0) $

/************************/
/* make simple vectors  */
/************************/
/* Real column and row vectors, Note: kets and bras are below */
cvec([u]) := transpose(matrix(u)) $
rvec([u]) := matrix(u) $

/************************/
/*   QM operations      */
/************************/
dag(u) := transpose(conjugate(u)) $ /* dagger */
braket(v,w) := block(
	    if ketp(v) and ketp(w) then dag(v) . w else
  	    if brap(v) and ketp(w) then v . w ) $
norm(v) := sqrt( braket(v,v) ) $
magsqr(c) := c*conjugate(c);
commutator(X,Y) := X.Y - Y.X;
expect(Op,psi) := dag(psi) . Op . psi $
qm_variance(Op,psi) := sqrt(expect(Op . Op,psi) - expect(Op,psi)^2) $

/* Born rule */
probability(psi,n) := magsqr(psi[n]);


/*********************/
/* make kets or bras */
/*********************/
/* most basic definition, but won't declare constants as complex */
ket([u]) := transpose(u) $
bra([u]) := matrix(u) $

/***************************************/
/* Define predicates for kets and bras */
/***************************************/
ketp(psi) := block([r,c],
     if matrixp(psi) then (
        [r,c] : matrix_size(psi),
        (c = 1) and (r > 1) and every(lambda([q], not (matrixp(q) or listp(q) or setp(q))), psi))
    else false);
brap(psi) := block([r,c],
     if matrixp(psi) then (
        [r,c] : matrix_size(psi),
        (r = 1) and (c > 1) and every(lambda([q], not (matrixp(q) or listp(q) or setp(q))), psi))
    else false);

/******************************************************/
/******************************************************/
/*              (j,m) kets and bras                   */
/******************************************************/
/******************************************************/
jm_ket(j,m) := [jmket, transpose(matrix([j,m]))]$
jm_bra(j,m) := [jmbra, matrix([j,m])]$
jm_braket(b,k) := block([j1,j2,m1,m2],
	     if b[1]#jmbra or k[1]#jmket then return(false),
	     j1:b[2][1][1], m1:b[2][1][2], j2:k[2][1][1], m2:k[2][2][1],
	     if j1=j2 and m1=m2 then return(1) else return(0) )$
jm_ketp(k) := if k[1]#jmket then false else true$
jm_brap(k) := if k[1]#jmbra then false else true$
jm_check(j,m) := block([pos:0],
	      if numberp(j)=false or numberp(m)=false then return(false) else
	      	 for jn: j step -1 thru -j do
		     if jn=m then pos:1,
		 if pos=1 then true else false )$
JP(k) := block([j,m,sqrterm],
      if k[1]#jmket then return(false),
      j:k[2][1][1], m:k[2][2][1], sqrterm:sqrt(j*(j+1)-m*(m+1))*hbar,
      return( sqrterm * 'jm_ket(j,m+1) ) )$
JM(k) := block([j,m,sqrterm],
      if k[1]#jmket then return(false),
      j:k[2][1][1], m:k[2][2][1], sqrterm:sqrt(j*(j+1)-m*(m-1))*hbar,
      return( sqrterm * 'jm_ket(j,m-1) ) )$
Jsqr(k) := block([j,m,sqrterm],
      if k[1]#jmket then return(false),
      j:k[2][1][1], return( (j*(j+1)) * hbar^2 * 'jm_ket(j,m) ) )$
Jz(k) := block([j,m,sqrterm],
      if k[1]#jmket then return(false),
      m:k[2][2][1], return( m * hbar * 'jm_ket(j,m) ) )$




/******************************************************/
/******************************************************/
/* Angular momentum ladder operators for general spin */
/******************************************************/
/******************************************************/
/*
disp("Angular momentum ladder ops:: SP(s), SM(s)") $
disp("General spin:: SX(s), SY(s), SZ(s); rot:: RZ(s,phi), RX(s,phi), RY(s,phi)") $
disp("Time-evolution operator:: UU(H,t)") $
*/
SP(s) := block([i,j,N,MM],
	N:2*s+1, MM: zeromatrix(N,N),
	mval: makelist(-s+i,i,0,N-1),
	for i: 1 thru N do
	    for j: i thru N do
	    	if is(i=(j+1))=true or is(i=(j-1))=true then 
		MM[i,j]: hbar*sqrt( s * (s+1) - mval[i] * (mval[i]+1) )
		else MM[i,j]:0,
	MM
	)$
	
SM(s) := dag(SP(s))$
SX(s) := (1/2)*(SP(s)+SM(s))$
SY(s) := (%i/2)*(SM(s)-SP(s))$
SZ(s) := 1/(%i*hbar)*commutator(SX(s),SY(s))$


/******************/
/* Spin-1/2 stuff */
/******************/

/* spin-1/2 state vectors */
zp : cvec(1,0) $
zm : cvec(0,1) $
xp : (1/sqrt(2))*(zp+zm) $
xm : (1/sqrt(2))*(zp-zm) $
yp : (1/sqrt(2))*(zp+%i*zm) $
ym : (1/sqrt(2))*(zp-%i*zm) $

/* Pauli sigma matrices */
sigmax : matrix([0,1],[1,0]) $
sigmay : matrix([0,-%i],[%i,0]) $
sigmaz : matrix([1,0],[0,-1]) $

/* spin-1/2 matrices */
Sz : SZ(1/2) $
Sx : SX(1/2) $
Sy : SY(1/2) $

/******************/
/* Spin-1 stuff */
/******************/

/* basis states for a spin-1 particle */
zu : cvec(1,0,0) $
zz : cvec(0,1,0) $
zd : cvec(0,0,1) $

/* spin-1 matrices
Sz1 : hbar*matrix([1,0,0],[0,0,0],[0,0,-1]) $
Sx1 : (hbar/sqrt(2))*matrix([0,1,0],[1,0,1],[0,1,0]) $
Sy1 : (hbar/sqrt(2))*matrix([0,-%i,0],[%i,0,-%i],[0,%i,0]) $ */
Sz1 : SZ(1) $
Sx1 : SX(1) $
Sy1 : SY(1) $


/****************************************/
/*         Rotation Operators           */
/****************************************/
Rot(Op,phi) := block([M1,M2,M3],
	  M1: matrixexp(-%i*Op*phi/hbar),
	  M2: matrixmap(distrib,M1),
	  M3: matrixmap(combine,M2),
	  trigreduce(M3)
	  )$

/* the following is so RZ appears with exponentials
   and RX and RY with trig functions */
RZ(s,t) := Rot(SZ(s),t)$
RX(s,t) := block([M], demoivre:true, M:Rot(SX(s),t), demoivre:false, M)$
RY(s,t) := block([M], demoivre:true, M:Rot(SY(s),t), demoivre:false, M)$

/* time-evolution operator */
UU(H,t) := block([M], demoivre:true, M:Rot(H,t), demoivre:false, M)$

/*****************************************************************/
/*****************************************************************/
/*****************************************************************/
/*                tensor products                                */
/*****************************************************************/
/*****************************************************************/
/*****************************************************************/

ketprod([u]) := block([N,fail:0],
	     N: length(u),
	     for i: 1 thru N do
	     	 if ketp(''u[i])=false then fail:1,
	     if fail=0 then [tpket,u]
	     else disp("all elements must be kets") )$

braprod([u]) := block([N,fail:0],
	     N: length(u),
	     for i: 1 thru N do
	     	 if brap(''u[i])=false then fail:1,
	     if fail=0 then [tpbra,u]
	     else disp("all elements must be bras") )$

braketprod(B,K) := block([N,M,fail:0,prod:1],
		if is(B[1]#tpbra) then return(false),
		if is(K[1]#tpket) then return(false),
		N: length(B[2]),
		M: length(K[2]),
		if M#N then return(false)
		else for i: 1 thru N do
		     prod: prod*braket(B[2][i],K[2][i]),
		prod )$
