/* Basis set utilities */
/* E.H. Majzoub        */
/* GPL 3 or greater    */

/*************************/
/* Matrix rep basis sets */
/*************************/
basis_set_p(B):=block([N:length(B)],
  for i: 1 thru N do
  if mketp(B[i])=false then return(false) else return(true) );

mtrans(B1,B2):=block([N1:length(B1),N2:length(B2),M],
  if basis_set_p(B1)=false or basis_set_p(B2)=false or N1#N2 then
     return(disp("Bad basis set(s)")),
  /* construct the transition matrix */
  M: zeromatrix(N1,N1),
  for i: 1 thru N1 do
     for j: 1 thru N1 do
        M[i,j]: dagger(B1[i]) . B2[j],
  M);

/* transform operator A from basis B1 to basis B2 */
op_trans(A,B1,B2):=block([N1:length(B1),N2:length(B2),M,Md],
  if basis_set_p(B1)=false or basis_set_p(B2)=false or N1#N2 then
     return(disp("Bad basis set(s)")),
  /* construct the transition matrix */
  M: mtrans(B1,B2), Md: dagger(M),
  Md . A . M);


/*******************************/
/*   Abstract basis sets       */
/*******************************/

/* Construct matrix representation of an operator A
in basis B. Note: if there are symbols as coefficients
in the kets, they must be declared 'scalar' for the
rules to work. */
matrep(A,B):=block([N:length(B),M,dotscrules:true,listarith:false],
  M: zeromatrix(N,N),
  for i: 1 thru N do
     for j: 1 thru N do
        if freeof("+",A)=false then /* allows for claculations with H = H1 + H2 +... */
           block([rho:expand(A)],
           for k: 1 thru length(rho) do
              if tpketp(B[i]) then M[i,j]: M[i,j] + tpbraket(tpdagger(B[i]) , part(rho,k) . B[j])
              else M[i,j]: M[i,j] + dagger(B[i]) . part(rho,k) . B[j])
        else
              if tpketp(B[i]) then M[i,j]: tpbraket(tpdagger(B[i]) , A . B[j])
              else M[i,j]: dagger(B[i]) . A . B[j],        
M);

/****************************/
/*        QM trace          */
/****************************/
/* matrix trace */
qm_mtrace(M) := if matrixp(M) then
      block([n:matrix_size(M)[1],m:matrix_size(M)[2],tr:0],
            if n # m then return(disp("matrix is not square"))
            else for i: 1 thru n do tr: tr + M[i,i], tr)
      else disp("function requires matrix as input");

/* abstract trace */
qm_atrace(A,B) := qm_mtrace( matrep(A,B) );
