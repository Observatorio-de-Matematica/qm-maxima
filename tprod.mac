/*****************************************************/
/*****************************************************/
/*             tensor product code                   */
/*****************************************************/
/*****************************************************/

/*
The tensor product code here is necessary for dealing with tensor
products of (j,m)-kets in order to do addition of addtion of angular
momentum calculations of Clebsh-Gordon coefficients. -ehm
*/

/***********************************/
/*          simp rules             */
/***********************************/
/* extended tensor product functionality */
/* The form of a type2 tensor product is the
    Maxima list [tpket,CF,k1,k2] 
where CF=common factors that come out of say Jz, etc. */

tpketp(k):=if k[1]=tpket then true else false $
tpbrap(k):=if k[1]=tpbra then true else false $

matchdeclare([k1,k2,k3,k4],ketp,[b1,b2],brap,ll,listp,pf,numberp);
tellsimp( tpket(k1,k2), [tpket,1,k1,k2] );
tellsimp( tpbra(b1,b2), [tpbra,1,b1,b2] );

matchdeclare([c1,c2,c3,c4,cf1,cf2],all);
tellsimpafter( [tpket,cf1,c1*k1,c2*k2], [tpket,cf1*c1*c2,k1,k2] );

tellsimp( [tpket,cf1,0,k2], 0 );
tellsimp( [tpket,cf1,k1,0], 0 );
tellsimp( [tpket,0,k1,k2], 0 );

/***********************************************/
/*        Function definitions                 */
/***********************************************/
tpcfset(cf,k):=[k[1],cf,k[3],k[4]];
tpscmult(f,tp):=[tp[1], f*tp[2], tp[3], tp[4]];

tpbraket(b,k):=block([R],
    if tpketp(k)=false or tpbrap(b)=false then return(disp("Inputs must be a single tpbra and tpket.")),
    R: b[2]*k[2]*( b[3] . k[3] )*( b[4] . k[4] ),
    R);

tpadd(tpka,tpkb):=block([R,q,fac:1,cfac:1],
    if tpka=0 then return(tpkb),
    if tpkb=0 then return(tpka),
    if tpka=0 and tpkb=0 then return(0),
    cfa:tpka[2],cfb:tpkb[2],
    if not tpka[1]=tpket or not tpkb[1]=tpket then return(disp("Input must be tpkets.")),
    if tpka[3]=tpkb[3] and tpka[4]=tpkb[4] then R: [tpket, cfa+cfb, tpka[3], tpka[4]],
    if tpka[3]=tpkb[3] and tpka[4]#tpkb[4] then R: [tpket, 1, tpka[3], cfa*tpka[4]+cfb*tpkb[4]], 
    if tpka[3]#tpkb[3] and tpka[4]=tpkb[4] then R: [tpket, 1, cfa*tpka[3]+cfb*tpkb[3], tpkb[4]],
    listarith:false,
    if tpka[3]#tpkb[3] and tpka[4]#tpkb[4] then R: [tpket, cfa, tpka[3], tpka[4]] +
       		       	   		   	   [tpket, cfb, tpkb[3], tpkb[4]],
    listarith:true,				   
    R);

tpdagger(tp):=block([R],
    if tp[1]=tpket then R:[tpbra,dagger(tp[2]),
    dagger(tp[3]),dagger(tp[4])]
    elseif tp[1]=tpbra then R:[tpket,dagger(tp[2]),
    dagger(tp[3]),dagger(tp[4])]
    else return(disp("must be a tpket or tpbra")),
    R);

J1z(k):= if tpketp(k) then [tpket,k[2],Jz(k[3]),k[4]];
J2z(k):= if tpketp(k) then [tpket,k[2],k[3],Jz(k[4])];
Jtz(k):= [tpket, J1z(k)[2]+J2z(k)[2], k[3],k[4] ];

J1sqr(k):= if tpketp(k) then [tpket,k[2],Jsqr(k[3]),k[4]];
J2sqr(k):= if tpketp(k) then [tpket,k[2],k[3],Jsqr(k[4])];

J1p(k):= if tpketp(k) then [tpket,k[2],JP(k[3]),k[4]];
J2p(k):= if tpketp(k) then [tpket,k[2],k[3],JP(k[4])];
Jtp(k):= block([R],listarith:false,
        if tpketp(k) then R: J1p(k)+J2p(k), listarit:true, R);
J1m(k):= if tpketp(k) then [tpket,k[2],JM(k[3]),k[4]];
J2m(k):= if tpketp(k) then [tpket,k[2],k[3],JM(k[4])];
Jtm(k):= block([R],listarith:false,
        if tpketp(k) then R: J1m(k)+J2m(k), listarith:true, R);

J1p2m(k):= block([R],
    if tpketp(k)=false then return(false),
    R:[tpket,k[2],JP(k[3]),JM(k[4])],
    if R[3]=0 or R[4]=0 then return(0),
    R);
J1m2p(k):= block([R],
    if tpketp(k)=false then return(false),
    R:[tpket,k[2],JM(k[3]),JP(k[4])],
    if R[3]=0 or R[4]=0 then return(0),
    R);

J1zJ2z(k):= block([R],
    if tpketp(k)=false then return(false),
    R:[tpket,k[2],Jz(k[3]),Jz(k[4])],
    if R[3]=0 or R[4]=0 then return(0),
    R);

/* Jtsqr = J1sqr + J2sqr + J1p*J2m + J1m*J2p + 2J1zJ2z */
Jtsqr(k):=block([R,r1,r2], 
    if tpketp(k)=false then return(disp("must enter a tpket")),
    r1: tpadd( J1sqr(k) , tpadd( J2sqr(k) , tpscmult(2,J1zJ2z(k)) )),
    r2: tpadd( J1p2m(k) , J1m2p(k)),
    R: tpadd(r1,r2),
    R);