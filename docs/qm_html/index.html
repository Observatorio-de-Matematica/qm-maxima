<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Top (Package qm)</title>

<meta name="description" content="Top (Package qm)">
<meta name="keywords" content="Top (Package qm)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="#Top" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="../dir_html/index.html" rel="up" title="(dir)">
<link href="#Introduction-to-package-qm" rel="next" title="Introduction to package qm">
<link href="../dir_html/index.html" rel="prev" title="(dir)">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">



<div class="top-level-extent" id="Top">
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<a class="top" id="SEC_Top"></a>


<ul class="mini-toc">
<li><a href="#Package-qm" accesskey="1">Package qm</a></li>
<li><a href="Function-and-Variable-Index.html" accesskey="2">Function and Variable index</a></li>
</ul>
<div class="chapter-level-extent" id="Package-qm">
<h2 class="chapter"><span>1 Package qm<a class="copiable-link" href="#Package-qm"> &para;</a></span></h2>

<ul class="mini-toc">
<li><a href="#Introduction-to-package-qm" accesskey="1">Introduction to package qm</a></li>
<li><a href="#Functions-and-Variables-for-qm" accesskey="2">Functions and Variables for qm</a></li>
<li><a href="#Rotation-operators" accesskey="3">Rotation operators</a></li>
<li><a href="#Time_002devolution-operator" accesskey="4">Time-evolution operator</a></li>
<li><a href="#Tensor-products" accesskey="5">Tensor products</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Introduction-to-package-qm">
<div class="nav-panel">
<p>
Next: <a href="#Functions-and-Variables-for-qm" accesskey="n" rel="next">Functions and Variables for qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-package-qm-1"><span>1.1 Introduction to package qm<a class="copiable-link" href="#Introduction-to-package-qm-1"> &para;</a></span></h3>

<p>Package version: 0.5
</p>
<p>The <code class="code">qm</code> package provides functions and standard definitions to
solve quantum mechanics problems in a finite dimensional Hilbert
space. For example, one can calculate the outcome of Stern-Gerlach
experiments using the built-in definition of the Sx, Sy, and Sz
operators for arbitrary spin, e.g. <code class="code">s={1/2, 1, 3/2,
&hellip;}</code>. For spin-1/2 the standard basis states in the <var class="var">x</var>,
<var class="var">y</var>, and <var class="var">z</var>-basis are available as <code class="code">{xp,xm}</code>,
<code class="code">{yp,ym}</code>, and <code class="code">{zp,zm}</code>. One can create general ket
vectors with arbitrary but finite dimension and perform standard
computations such as expectation value, variance, etc. The angular
momentum <var class="var">|j,m&gt;</var> representation of kets is also available. It is
also possible to create tensor product states for multiparticle systems
and to perform calculations on those systems.
</p>
<p>The <code class="code">qm</code> package was written by Eric Majzoub, University of
Missouri.  (Email: majzoube-at-umsystem.edu) The package is loaded with:
<code class="code">load(qm);</code>
</p>
<hr>
</div>
<div class="section-level-extent" id="Functions-and-Variables-for-qm">
<div class="nav-panel">
<p>
Previous: <a href="#Introduction-to-package-qm" accesskey="p" rel="prev">Introduction to package qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-qm-1"><span>1.2 Functions and Variables for qm<a class="copiable-link" href="#Functions-and-Variables-for-qm-1"> &para;</a></span></h3>

<dl class="first-defvr">
<dt class="defvr" id="index-hbar"><span class="category-def">Variable: </span><span><strong class="def-name">hbar</strong><a class="copiable-link" href="#index-hbar"> &para;</a></span></dt>
<dd><p>Planck&rsquo;s constant divided by <code class="code">2*%pi</code>. <code class="code">hbar</code> is not given a
floating point value, but is declared to be a real number greater than
zero.
</p></dd></dl>

<a class="anchor" id="ket"></a><dl class="first-deffn">
<dt class="deffn" id="index-ket"><span class="category-def">Function: </span><span><strong class="def-name">ket</strong> <var class="def-var-arguments">(<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;)</var><a class="copiable-link" href="#index-ket"> &para;</a></span></dt>
<dd><p><code class="code">ket</code> creates a <em class="emph">column</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) declare([c1,c2],complex);
(%o4)                                done
(%i5) ket(c1,c2);
                                    [ c1 ]
(%o5)                               [    ]
                                    [ c2 ]
(%i6) facts();
(%o6) [kind(hbar, real), hbar &gt; 0, kind(c1, complex), kind(c2, complex)]
</pre></div></div>

<a class="anchor" id="bra"></a><dl class="first-deffn">
<dt class="deffn" id="index-bra"><span class="category-def">Function: </span><span><strong class="def-name">bra</strong> <var class="def-var-arguments">(<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;)</var><a class="copiable-link" href="#index-bra"> &para;</a></span></dt>
<dd><p><code class="code">bra</code> creates a <em class="emph">row</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) bra(c1,c2);
(%o4)                             [ c1  c2 ]
(%i5) facts();
(%o5)                    [kind(hbar, real), hbar &gt; 0]
</pre></div></div>

<a class="anchor" id="ketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-ketp"><span class="category-def">Function: </span><span><strong class="def-name">ketp</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-ketp"> &para;</a></span></dt>
<dd><p><code class="code">ketp</code> is a predicate function that checks if its input is a ket,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) b:bra(a,b);
(%o4)                              [ a  b ]
(%i5) ketp(b);
(%o5)                                false
</pre></div></div>

<a class="anchor" id="brap"></a><dl class="first-deffn">
<dt class="deffn" id="index-brap"><span class="category-def">Function: </span><span><strong class="def-name">brap</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-brap"> &para;</a></span></dt>
<dd><p><code class="code">brap</code> is a predicate function that checks if its input is a bra,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) b:bra(a,b);
(%o4)                              [ a  b ]
(%i5) brap(b);
(%o5)                                true
</pre></div></div>

<a class="anchor" id="dagger"></a><dl class="first-deffn">
<dt class="deffn" id="index-dagger"><span class="category-def">Function: </span><span><strong class="def-name">dagger</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-dagger"> &para;</a></span></dt>
<dd><p><code class="code">dagger</code> is the quantum mechanical <em class="emph">dagger</em> function and returns
the <code class="code">conjugate</code> <code class="code">transpose</code> of its input.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) dagger(bra(%i,2));
                                   [ - %i ]
(%o4)                              [      ]
                                   [  2   ]
</pre></div></div>

<a class="anchor" id="braket"></a><dl class="first-deffn">
<dt class="deffn" id="index-braket"><span class="category-def">Function: </span><span><strong class="def-name">braket</strong> <var class="def-var-arguments">(<code class="code">psi,phi</code>)</var><a class="copiable-link" href="#index-braket"> &para;</a></span></dt>
<dd><p>Given two kets <code class="code">psi</code> and <code class="code">phi</code>, <code class="code">braket</code> returns the
quantum mechanical bracket <code class="code">&lt;psi|phi&gt;</code>. The vector <code class="code">psi</code> may be
input as either a <code class="code">ket</code> or <code class="code">bra</code>. If it is a <code class="code">ket</code> it will be
turned into a <code class="code">bra</code> with the <code class="code">dagger</code> function before the inner
product is taken. The vector <code class="code">phi</code> must always be a <code class="code">ket</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) declare([a,b,c],complex);
(%o4)                                done
(%i5) braket(ket(a,b,c),ket(a,b,c));
(%o5)          c conjugate(c) + b conjugate(b) + a conjugate(a)
</pre></div></div>

<a class="anchor" id="norm"></a><dl class="first-deffn">
<dt class="deffn" id="index-norm"><span class="category-def">Function: </span><span><strong class="def-name">norm</strong> <var class="def-var-arguments">(<code class="code">psi</code>)</var><a class="copiable-link" href="#index-norm"> &para;</a></span></dt>
<dd><p>Given a <code class="code">ket</code> or <code class="code">bra</code> <code class="code">psi</code>, <code class="code">norm</code> returns the
square root of the quantum mechanical bracket <code class="code">&lt;psi|psi&gt;</code>.
The vector <code class="code">psi</code> must always be a <code class="code">ket</code>, otherwise the
function will return <code class="code">false</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) declare([a,b,c],complex);
(%o4)                                done
(%i5) norm(ket(a,b,c));
(%o5)       sqrt(c conjugate(c) + b conjugate(b) + a conjugate(a))
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-magsqr"><span class="category-def">Function: </span><span><strong class="def-name">magsqr</strong> <var class="def-var-arguments">(<code class="code">c</code>)</var><a class="copiable-link" href="#index-magsqr"> &para;</a></span></dt>
<dd><p><code class="code">magsqr</code> returns <code class="code">conjugate(c)*c</code>, the magnitude
squared of a complex number.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) declare([a,b,c,d],complex);
(%o4)                                done
(%i5) A:braket(ket(a,b),ket(c,d));
(%o5)                   conjugate(b) d + conjugate(a) c
(%i6) P:magsqr(A);
(%o6) (conjugate(b) d + conjugate(a) c) (b conjugate(d) + a conjugate(c))
</pre></div></div>

<ul class="mini-toc">
<li><a href="#Spin_002d1_002f2-state-kets-and-associated-operators" accesskey="1">Spin-1/2 state kets and associated operators</a></li>
<li><a href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators" accesskey="2">Pauli matrices and Sz, Sx, Sy operators</a></li>
<li><a href="#SX_002c-SY_002c-SZ-operators-for-any-spin" accesskey="3">SX, SY, SZ operators for any spin</a></li>
<li><a href="#Expectation-value-and-variance" accesskey="4">Expectation value and variance</a></li>
<li><a href="#Angular-momentum-representation-of-kets-and-bras" accesskey="5">Angular momentum representation of kets and bras</a></li>
<li><a href="#Angular-momentum-and-ladder-operators" accesskey="6">Angular momentum and ladder operators</a></li>
</ul>
<div class="subsection-level-extent" id="Spin_002d1_002f2-state-kets-and-associated-operators">
<h4 class="subsection"><span>1.2.1 Spin-1/2 state kets and associated operators<a class="copiable-link" href="#Spin_002d1_002f2-state-kets-and-associated-operators"> &para;</a></span></h4>

<p>Spin-1/2 particles are characterized by a simple 2-dimensional Hilbert
space of states. It is spanned by two vectors. In the <var class="var">z</var>-basis
these vectors are <code class="code">{zp,zm}</code>, and the basis kets in the
<var class="var">z</var>-basis are <code class="code">{xp,xm}</code> and <code class="code">{yp,ym}</code> respectively.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-zp"><span class="category-def">Function: </span><span><strong class="def-name">zp</strong><a class="copiable-link" href="#index-zp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-zm"><span class="category-def">Function: </span><span><strong class="def-name">zm</strong><a class="copiable-link" href="#index-zm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-xp"><span class="category-def">Function: </span><span><strong class="def-name">xp</strong><a class="copiable-link" href="#index-xp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-xm"><span class="category-def">Function: </span><span><strong class="def-name">xm</strong><a class="copiable-link" href="#index-xm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-yp"><span class="category-def">Function: </span><span><strong class="def-name">yp</strong><a class="copiable-link" href="#index-yp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ym"><span class="category-def">Function: </span><span><strong class="def-name">ym</strong><a class="copiable-link" href="#index-ym"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) zp;
                                     [ 1 ]
(%o4)                                [   ]
                                     [ 0 ]
(%i5) zm;
                                     [ 0 ]
(%o5)                                [   ]
                                     [ 1 ]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) yp;
                                  [    1    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%o4)                             [         ]
                                  [   %i    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%i5) ym;
                                 [     1     ]
                                 [  -------  ]
                                 [  sqrt(2)  ]
(%o5)                            [           ]
                                 [     %i    ]
                                 [ - ------- ]
                                 [   sqrt(2) ]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) braket(xp,zp);
                                       1
(%o4)                               -------
                                    sqrt(2)
</pre></div></div>

<p>Switching bases is done in the following example where a <var class="var">z</var>-basis
ket is constructed and the <var class="var">x</var>-basis ket is computed.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) declare([a,b],complex);
(%o4)                                done
(%i5) psi:ket(a,b);
                                     [ a ]
(%o5)                                [   ]
                                     [ b ]
(%i6) psi_x:'xp*braket(xp,psi)+'xm*braket(xm,psi);
                    b         a              a         b
(%o6)           (------- + -------) xp + (------- - -------) xm
                 sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators">
<h4 class="subsection"><span>1.2.2 Pauli matrices and Sz, Sx, Sy operators<a class="copiable-link" href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmax"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmax</code></strong><a class="copiable-link" href="#index-sigmax"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">x</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmay"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmay</code></strong><a class="copiable-link" href="#index-sigmay"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">y</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmaz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmaz</code></strong><a class="copiable-link" href="#index-sigmaz"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">z</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sx"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sx</code></strong><a class="copiable-link" href="#index-Sx"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sx</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sy"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sy</code></strong><a class="copiable-link" href="#index-Sy"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sy</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sz</code></strong><a class="copiable-link" href="#index-Sz"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sz</var> matrix.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) sigmay;
                                 [ 0   - %i ]
(%o4)                            [          ]
                                 [ %i   0   ]
(%i5) Sy;
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o5)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-commutator"><span class="category-def">Function: </span><span><strong class="def-name">commutator</strong> <var class="def-var-arguments">(<code class="code">X,Y</code>)</var><a class="copiable-link" href="#index-commutator"> &para;</a></span></dt>
<dd><p>Given two operators <code class="code">X</code> and <code class="code">Y</code>, return the
commutator <code class="code">X . Y - Y . X</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) commutator(Sx,Sy);
                           [        2             ]
                           [ %i hbar              ]
                           [ --------      0      ]
                           [    2                 ]
(%o4)                      [                      ]
                           [                    2 ]
                           [             %i hbar  ]
                           [    0      - -------- ]
                           [                2     ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="SX_002c-SY_002c-SZ-operators-for-any-spin">
<h4 class="subsection"><span>1.2.3 SX, SY, SZ operators for any spin<a class="copiable-link" href="#SX_002c-SY_002c-SZ-operators-for-any-spin"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-SX"><span class="category-def">Function: </span><span><strong class="def-name">SX</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SX"> &para;</a></span></dt>
<dd><p><code class="code">SX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sx</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SY"><span class="category-def">Function: </span><span><strong class="def-name">SY</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SY"> &para;</a></span></dt>
<dd><p><code class="code">SY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sy</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SZ"><span class="category-def">Function: </span><span><strong class="def-name">SZ</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SZ"> &para;</a></span></dt>
<dd><p><code class="code">SZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sz</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<p>Example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) SY(1/2);
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o4)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
(%i5) SX(1);
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
                         [                           ]
                         [  hbar              hbar   ]
(%o5)                    [ -------     0     ------- ]
                         [ sqrt(2)           sqrt(2) ]
                         [                           ]
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Expectation-value-and-variance">
<h4 class="subsection"><span>1.2.4 Expectation value and variance<a class="copiable-link" href="#Expectation-value-and-variance"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-expect"><span class="category-def">Function: </span><span><strong class="def-name">expect</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-expect"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical expectation value of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">&lt;psi|O|psi&gt;</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) ev(expect(Sy,xp+ym),ratsimp);
(%o4)                               - hbar
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-qm_005fvariance"><span class="category-def">Function: </span><span><strong class="def-name">qm_variance</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-qm_005fvariance"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical variance of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">sqrt(&lt;psi|O<sup class="sup">2</sup>|psi&gt; - &lt;psi|O|psi&gt;<sup class="sup">2</sup>)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) ev(qm_variance(Sy,xp+ym),ratsimp);
                                    %i hbar
(%o4)                               -------
                                       2
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Angular-momentum-representation-of-kets-and-bras">
<h4 class="subsection"><span>1.2.5 Angular momentum representation of kets and bras<a class="copiable-link" href="#Angular-momentum-representation-of-kets-and-bras"> &para;</a></span></h4>

<p>To create kets and bras in the <var class="var">|j,m&gt;</var> representation you can use
the following functions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fket"><span class="category-def">Function: </span><span><strong class="def-name">jm_ket</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jm_005fket"> &para;</a></span></dt>
<dd><p><code class="code">jm_ket</code> creates the ket <var class="var">|j,m&gt;</var> for total spin <var class="var">j</var>
and <var class="var">z</var>-component <var class="var">m</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fbra"><span class="category-def">Function: </span><span><strong class="def-name">jm_bra</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jm_005fbra"> &para;</a></span></dt>
<dd><p><code class="code">jm_bra</code> creates the bra <var class="var">&lt;j,m|</var> for total spin <var class="var">j</var>
and <var class="var">z</var>-component <var class="var">m</var>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) jm_bra(3/2,1/2);
                                       [ 3  1 ]
(%o4)                          [jmbra, [ -  - ]]
                                       [ 2  2 ]
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fketp"><span class="category-def">Function: </span><span><strong class="def-name">jm_ketp</strong> <var class="def-var-arguments">(jmket)</var><a class="copiable-link" href="#index-jm_005fketp"> &para;</a></span></dt>
<dd><p><code class="code">jm_ketp</code> checks to see that the ket has the &rsquo;jmket&rsquo; marker.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fbrap"><span class="category-def">Function: </span><span><strong class="def-name">jm_brap</strong> <var class="def-var-arguments">(jmbra)</var><a class="copiable-link" href="#index-jm_005fbrap"> &para;</a></span></dt>
<dd><p><code class="code">jm_brap</code> checks to see that the bra has the &rsquo;jmbra&rsquo; marker.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fcheck"><span class="category-def">Function: </span><span><strong class="def-name">jm_check</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jm_005fcheck"> &para;</a></span></dt>
<dd><p><code class="code">jm_check</code> checks to see that <var class="var">m</var> is one of {-j, &hellip;, +j}.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fbraket"><span class="category-def">Function: </span><span><strong class="def-name">jm_braket</strong> <var class="def-var-arguments">(<code class="code">jmbra,jmket</code>)</var><a class="copiable-link" href="#index-jm_005fbraket"> &para;</a></span></dt>
<dd><p><code class="code">jm_braket</code> takes the inner product of the jm-kets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) K:jm_ket(zp,zm);
                                      [ [ 1 ] ]
                                      [ [   ] ]
                                      [ [ 0 ] ]
(%o4)                         [jmket, [       ]]
                                      [ [ 0 ] ]
                                      [ [   ] ]
                                      [ [ 1 ] ]
(%i5) B:jm_bra(zp,zm);
                                   [ [ 1 ]  [ 0 ] ]
(%o5)                      [jmbra, [ [   ]  [   ] ]]
                                   [ [ 0 ]  [ 1 ] ]
(%i6) jm_braket(B,K);
(%o6)                                  1
</pre></div></div>


</div>
<div class="subsection-level-extent" id="Angular-momentum-and-ladder-operators">
<h4 class="subsection"><span>1.2.6 Angular momentum and ladder operators<a class="copiable-link" href="#Angular-momentum-and-ladder-operators"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-SP"><span class="category-def">Function: </span><span><strong class="def-name">SP</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SP"> &para;</a></span></dt>
<dd><p><code class="code">SP</code> is the raising ladder operator <var class="var">S<sub class="sub">+</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SM"><span class="category-def">Function: </span><span><strong class="def-name">SM</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SM"> &para;</a></span></dt>
<dd><p><code class="code">SM</code> is the raising ladder operator <var class="var">S<sub class="sub">-</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<p>Examples of the ladder operators:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) SP(1);
                       [ 0  sqrt(2) hbar       0       ]
                       [                               ]
(%o4)                  [ 0       0        sqrt(2) hbar ]
                       [                               ]
                       [ 0       0             0       ]
(%i5) SM(1);
                       [      0             0        0 ]
                       [                               ]
(%o5)                  [ sqrt(2) hbar       0        0 ]
                       [                               ]
                       [      0        sqrt(2) hbar  0 ]
</pre></div></div>

</div>
</div>
<div class="section-level-extent" id="Rotation-operators">
<h3 class="section"><span>1.3 Rotation operators<a class="copiable-link" href="#Rotation-operators"> &para;</a></span></h3>

<dl class="first-deffn">
<dt class="deffn" id="index-RX"><span class="category-def">Function: </span><span><strong class="def-name">RX</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RX"> &para;</a></span></dt>
<dd><p><code class="code">RX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rx</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-RY"><span class="category-def">Function: </span><span><strong class="def-name">RY</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RY"> &para;</a></span></dt>
<dd><p><code class="code">RY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Ry</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-RZ"><span class="category-def">Function: </span><span><strong class="def-name">RZ</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RZ"> &para;</a></span></dt>
<dd><p><code class="code">RZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rz</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) RZ(1/2,t);
Proviso: assuming 64*t # 0 
                             [     %i t         ]
                             [   - ----         ]
                             [      2           ]
                             [ %e          0    ]
(%o4)                        [                  ]
                             [             %i t ]
                             [             ---- ]
                             [              2   ]
                             [    0      %e     ]
</pre></div></div>

</div>
<div class="section-level-extent" id="Time_002devolution-operator">
<h3 class="section"><span>1.4 Time-evolution operator<a class="copiable-link" href="#Time_002devolution-operator"> &para;</a></span></h3>

<dl class="first-deffn">
<dt class="deffn" id="index-UU"><span class="category-def">Function: </span><span><strong class="def-name">UU</strong> <var class="def-var-arguments">(<code class="code">H,t</code>)</var><a class="copiable-link" href="#index-UU"> &para;</a></span></dt>
<dd><p><code class="code">UU(H,t)</code> is the time evolution operator for Hamiltonian <code class="code">H</code>. It
is defined as the matrix exponential <code class="code">matrixexp(-%i*H*t/hbar)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) UU(w*Sy,t);
Proviso: assuming 64*t*w # 0 
                           [     t w         t w  ]
                           [ cos(---)  - sin(---) ]
                           [      2           2   ]
(%o4)                      [                      ]
                           [     t w        t w   ]
                           [ sin(---)   cos(---)  ]
                           [      2          2    ]
</pre></div></div>

</div>
<div class="section-level-extent" id="Tensor-products">
<h3 class="section"><span>1.5 Tensor products<a class="copiable-link" href="#Tensor-products"> &para;</a></span></h3>

<p>Tensor products are represented as lists in Maxima. The ket tensor
product <code class="code">|z+,z+&gt;</code> is represented as <code class="code">[tpket,zp,zp]</code>, and the bra
tensor product <code class="code">&lt;a,b|</code> is represented as <code class="code">[tpbra,a,b]</code> for kets
<code class="code">a</code> and <code class="code">b</code>. The list labels <code class="code">tpket</code> and <code class="code">tpbra</code>
ensure calculations are performed with the correct kind of objects.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-ketprod"><span class="category-def">Function: </span><span><strong class="def-name">ketprod</strong> <var class="def-var-arguments">(<code class="code">k<sub class="sub">1</sub></code>, <code class="code">k<sub class="sub">2</sub></code>, &hellip;)</var><a class="copiable-link" href="#index-ketprod"> &para;</a></span></dt>
<dd><p><code class="code">ketprod</code> produces a tensor product of kets <code class="code">k<sub class="sub">i</sub></code>. All
of the elements must pass the <code class="code">ketp</code> predicate test to be
accepted.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-braprod"><span class="category-def">Function: </span><span><strong class="def-name">braprod</strong> <var class="def-var-arguments">(<code class="code">b<sub class="sub">1</sub></code>, <code class="code">b<sub class="sub">2</sub></code>, &hellip;)</var><a class="copiable-link" href="#index-braprod"> &para;</a></span></dt>
<dd><p><code class="code">braprod</code> produces a tensor product of bras <code class="code">b<sub class="sub">i</sub></code>. All
of the elements must pass the <code class="code">brap</code> predicate test to be
accepted.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-braketprod"><span class="category-def">Function: </span><span><strong class="def-name">braketprod</strong> <var class="def-var-arguments">(<code class="code">B,K</code>)</var><a class="copiable-link" href="#index-braketprod"> &para;</a></span></dt>
<dd><p><code class="code">braketprod</code> takes the inner product of the tensor products
<code class="code">B</code> and <code class="code">K</code>. The tensor products must be of the same length
(number of kets must equal the number of bras).
</p></dd></dl>

<p>Examples below show how to create tensor products and take
the bracket of tensor products.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i4) ketprod(zp,zm);
                                     [ 1 ]  [ 0 ]
(%o4)                       [tpket, [[   ], [   ]]]
                                     [ 0 ]  [ 1 ]
(%i5) ketprod('zp,'zm);
                           all elements must be kets

(%o5)                                done
</pre></div><div class="group"><pre class="example-preformatted">(%i4) kill(a,b,c,d);
(%o4)                                done
(%i5) declare([a,b,c,d],complex);
(%o5)                                done
(%i6) braprod(bra(a,b),bra(c,d));
(%o6)                    [tpbra, [[ a  b ], [ c  d ]]]
(%i7) braprod(dagger(zp),bra(c,d));
(%o7)                    [tpbra, [[ 1  0 ], [ c  d ]]]
</pre></div><div class="group"><pre class="example-preformatted">(%i4) zpb:dagger(zp);
(%o4)                              [ 1  0 ]
(%i5) zmb:dagger(zm);
(%o5)                              [ 0  1 ]
(%i6) K:ketprod('zp,'zm);
                           all elements must be kets

(%o6)                                done
(%i7) B:braprod(zpb,zmb);
(%o7)                    [tpbra, [[ 1  0 ], [ 0  1 ]]]
(%i8) B:braprod('zpb,'zmb);
                           all elements must be bras

(%o8)                                done
(%i9) braketprod(K,B);
(%o9)                                false
(%i10) braketprod(B,K);
(%o10)                               false
</pre></div></div>

</div>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
