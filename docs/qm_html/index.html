<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Top (Package qm)</title>

<meta name="description" content="Top (Package qm)">
<meta name="keywords" content="Top (Package qm)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="#Top" rel="start" title="Top">
<link href="Function-and-Variable-Index.html" rel="index" title="Function and Variable Index">
<link href="../dir_html/index.html" rel="up" title="(dir)">
<link href="#Introduction-to-package-qm" rel="next" title="Introduction to package qm">
<link href="../dir_html/index.html" rel="prev" title="(dir)">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">



<div class="top-level-extent" id="Top">
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<a class="top" id="SEC_Top"></a>


<ul class="mini-toc">
<li><a href="#Package-qm" accesskey="1">Package qm</a></li>
<li><a href="Function-and-Variable-Index.html" accesskey="2">Function and Variable index</a></li>
</ul>
<div class="chapter-level-extent" id="Package-qm">
<h2 class="chapter"><span>1 Package qm<a class="copiable-link" href="#Package-qm"> &para;</a></span></h2>

<ul class="mini-toc">
<li><a href="#Introduction-to-package-qm" accesskey="1">Introduction to package qm</a></li>
<li><a href="#Functions-and-Variables-for-qm" accesskey="2">Functions and Variables for qm</a></li>
<li><a href="#Rotation-operators" accesskey="3">Rotation operators</a></li>
<li><a href="#Time_002devolution-operator" accesskey="4">Time-evolution operator</a></li>
<li><a href="#Tensor-products" accesskey="5">Tensor products</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Introduction-to-package-qm">
<div class="nav-panel">
<p>
Next: <a href="#Functions-and-Variables-for-qm" accesskey="n" rel="next">Functions and Variables for qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Introduction-to-package-qm-1"><span>1.1 Introduction to package qm<a class="copiable-link" href="#Introduction-to-package-qm-1"> &para;</a></span></h3>

<p>The <code class="code">qm</code> package was written by Eric Majzoub, University of
Missouri. Email: majzoube-at-umsystem.edu
</p>
<p>The <code class="code">qm</code> package provides functions and standard definitions to
solve quantum mechanics problems in a finite dimensional Hilbert
space. For example, one can calculate the outcome of Stern-Gerlach
experiments using the built-in definition of the Sx, Sy, and Sz
operators for arbitrary spin, e.g. <code class="code">s={1/2, 1, 3/2,
&hellip;}</code>. For spin-1/2 the standard basis states in the <var class="var">x</var>,
<var class="var">y</var>, and <var class="var">z</var>-basis are available as <code class="code">{xp,xm}</code>,
<code class="code">{yp,ym}</code>, and <code class="code">{zp,zm}</code>. One can create general ket
vectors with arbitrary but finite dimension and perform standard
computations such as expectation value, variance, etc. The angular
momentum <var class="var">|j,m&gt;</var> representation of kets is also available. It is
also possible to create tensor product states for multiparticle systems
and to perform calculations on those systems.
</p>
<p>Kets and bras are represented by column and row vectors, respectively.
For spin-1/2 particles, for example, the bra vector
</p>
<p><code class="code">&lt;psi| = a &lt;z+| + b &lt;z-|</code>
</p>
<p>is represented by the row vector <code class="code">[a b]</code>, where the basis vectors
are
</p>
<p><code class="code">&lt;z+| = [1 0]</code>
</p>
<p>and
</p>
<p><code class="code">&lt;z-| = [0 1]</code>.
</p>
<p>Generally, if one wishes to do purely symbolic calculations, then input
of basic kets, (j,m)-kets, and so forth should be done without lists. If
one wishes to do numerical computations using the kets then enter the
arguments as a list. The following examples illustrate some of the basic
capabilities of the <code class="code">qm</code> package.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ket(a,b)+ket(c,d);
(%o1)                           |c, d&gt; + |a, b&gt;
(%i2) ket([a,b,c])+ket([d,e,f]);
                                   [ d + a ]
                                   [       ]
(%o2)                              [ e + b ]
                                   [       ]
                                   [ f + c ]
</pre></div></div>

<p>Tensor products of the spin-1/2 basis states <code class="code">{zp,zm}</code> in abstract
and matrix representations.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ketprod('zp,'zm)+ketprod('zm,'zp);
(%o1)                  ketprod(zp, zm) + ketprod(zm, zp)
(%i2) ketprod([zp,zm]);
                                     [ 1 ]  [ 0 ]
(%o2)                       [tpket, [[   ], [   ]]]
                                     [ 0 ]  [ 1 ]
</pre></div></div>

<p>Examples using abstract orthonormal kets.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b],complex);
(%o1)                                done
(%i2) psi:a*ket(1)+b*ket(2);
(%o2)                            |2&gt; b + |1&gt; a
(%i3) psidag:dagger(psi);
(%o3)                 &lt;2| conjugate(b) + &lt;1| conjugate(a)
(%i4) psidag . psi;
(%o4)                   b conjugate(b) + a conjugate(a)
</pre></div><div class="group"><pre class="example-preformatted">(%i1) declare([c1,c2],complex,r,real);
(%o1)                                done
(%i2) k:ket([c1,c2,r]);
                                    [ c1 ]
                                    [    ]
(%o2)                               [ c2 ]
                                    [    ]
                                    [ r  ]
(%i3) b:dagger(k);
(%o3)                 [ conjugate(c1)  conjugate(c2)  r ]
(%i4) b . k;
                    2
(%o4)              r  + c2 conjugate(c2) + c1 conjugate(c1)
</pre></div></div>

<p>The package is loaded with: <code class="code">load(qm);</code>
</p>
<hr>
</div>
<div class="section-level-extent" id="Functions-and-Variables-for-qm">
<div class="nav-panel">
<p>
Previous: <a href="#Introduction-to-package-qm" accesskey="p" rel="prev">Introduction to package qm</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Functions-and-Variables-for-qm-1"><span>1.2 Functions and Variables for qm<a class="copiable-link" href="#Functions-and-Variables-for-qm-1"> &para;</a></span></h3>

<dl class="first-defvr">
<dt class="defvr" id="index-hbar"><span class="category-def">Variable: </span><span><strong class="def-name">hbar</strong><a class="copiable-link" href="#index-hbar"> &para;</a></span></dt>
<dd><p>Planck&rsquo;s constant divided by <code class="code">2*%pi</code>. <code class="code">hbar</code> is not given a
floating point value, but is declared to be a real number greater than
zero.
</p></dd></dl>

<a class="anchor" id="ket"></a><dl class="first-deffn">
<dt class="deffn" id="index-ket"><span class="category-def">Function: </span><span><strong class="def-name">ket</strong> <var class="def-var-arguments">([<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-ket"> &para;</a></span></dt>
<dd><p><code class="code">ket</code> creates a <em class="emph">column</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex.
For a matrix representation the elements must be entered as a list
in <code class="code">[&hellip;]</code> square brackets. If no list is entered the ket
is represented as a general ket, <code class="code">ket(a)</code> will return <code class="code">|a&gt;</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) kill(a);
(%o1)                                done
(%i2) ket(a);
(%o2)                                 |a&gt;
(%i3) declare([c1,c2],complex);
(%o3)                                done
(%i4) ket([c1,c2]);
                                    [ c1 ]
(%o4)                               [    ]
                                    [ c2 ]
(%i5) facts();
(%o5) [kind(hbar, real), hbar &gt; 0, kind(c1, complex), kind(c2, complex)]
</pre></div></div>

<a class="anchor" id="bra"></a><dl class="first-deffn">
<dt class="deffn" id="index-bra"><span class="category-def">Function: </span><span><strong class="def-name">bra</strong> <var class="def-var-arguments">([<code class="code">c<sub class="sub">1</sub></code>,<code class="code">c<sub class="sub">2</sub></code>,&hellip;])</var><a class="copiable-link" href="#index-bra"> &para;</a></span></dt>
<dd><p><code class="code">bra</code> creates a <em class="emph">row</em> vector of arbitrary finite
dimension. The entries <code class="code">c<sub class="sub">i</sub></code> can be any Maxima expression.
The user must <code class="code">declare</code> any relevant constants to be complex.
For a matrix representation the elements must be entered as a list
in <code class="code">[&hellip;]</code> square bracbras. If no list is entered the bra
is represented as a general bra, <code class="code">bra(a)</code> will return <code class="code">&lt;a|</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) kill(c1,c2);
(%o1)                                done
(%i2) bra(c1,c2);
(%o2)                              &lt;c1, c2|
(%i3) bra([c1,c2]);
(%o3)                             [ c1  c2 ]
(%i4) facts();
(%o4)                    [kind(hbar, real), hbar &gt; 0]
</pre></div></div>

<a class="anchor" id="ketp"></a><dl class="first-deffn">
<dt class="deffn" id="index-ketp"><span class="category-def">Function: </span><span><strong class="def-name">ketp</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-ketp"> &para;</a></span></dt>
<dd><p><code class="code">ketp</code> is a predicate function that checks if its input is a ket,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
<code class="code">ketp</code> only returns <code class="code">true</code> for the matrix representation of a ket.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) kill(a,b,k);
(%o1)                                done
(%i2) k:ket(a,b);
(%o2)                               |a, b&gt;
(%i3) ketp(k);
(%o3)                                false
(%i4) k:ket([a,b]);
                                     [ a ]
(%o4)                                [   ]
                                     [ b ]
(%i5) ketp(k);
(%o5)                                true
</pre></div></div>

<a class="anchor" id="brap"></a><dl class="first-deffn">
<dt class="deffn" id="index-brap"><span class="category-def">Function: </span><span><strong class="def-name">brap</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-brap"> &para;</a></span></dt>
<dd><p><code class="code">brap</code> is a predicate function that checks if its input is a bra,
in which case it returns <code class="code">true</code>, else it returns <code class="code">false</code>.
<code class="code">brap</code> only returns <code class="code">true</code> for the matrix representation of a bra.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) b:bra([a,b]);
(%o1)                              [ a  b ]
(%i2) brap(b);
(%o2)                                true
</pre></div></div>

<a class="anchor" id="dagger"></a><dl class="first-deffn">
<dt class="deffn" id="index-dagger"><span class="category-def">Function: </span><span><strong class="def-name">dagger</strong> <var class="def-var-arguments">(<em class="emph">vector</em>)</var><a class="copiable-link" href="#index-dagger"> &para;</a></span></dt>
<dd><p><code class="code">dagger</code> is the quantum mechanical <em class="emph">dagger</em> function and returns
the <code class="code">conjugate</code> <code class="code">transpose</code> of its input.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) dagger(bra([%i,2]));
                                   [ - %i ]
(%o1)                              [      ]
                                   [  2   ]
</pre></div></div>

<a class="anchor" id="braket"></a><dl class="first-deffn">
<dt class="deffn" id="index-braket"><span class="category-def">Function: </span><span><strong class="def-name">braket</strong> <var class="def-var-arguments">(<code class="code">psi,phi</code>)</var><a class="copiable-link" href="#index-braket"> &para;</a></span></dt>
<dd><p>Given two kets <code class="code">psi</code> and <code class="code">phi</code>, <code class="code">braket</code> returns the
quantum mechanical bracket <code class="code">&lt;psi|phi&gt;</code>. The vector <code class="code">psi</code> may be
input as either a <code class="code">ket</code> or <code class="code">bra</code>. If it is a <code class="code">ket</code> it will be
turned into a <code class="code">bra</code> with the <code class="code">dagger</code> function before the inner
product is taken. The vector <code class="code">phi</code> must always be a <code class="code">ket</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c],complex);
(%o1)                                done
(%i2) braket(ket([a,b,c]),ket([a,b,c]));
(%o2)          c conjugate(c) + b conjugate(b) + a conjugate(a)
</pre></div></div>

<a class="anchor" id="norm"></a><dl class="first-deffn">
<dt class="deffn" id="index-norm"><span class="category-def">Function: </span><span><strong class="def-name">norm</strong> <var class="def-var-arguments">(<code class="code">psi</code>)</var><a class="copiable-link" href="#index-norm"> &para;</a></span></dt>
<dd><p>Given a <code class="code">ket</code> or <code class="code">bra</code> <code class="code">psi</code>, <code class="code">norm</code> returns the
square root of the quantum mechanical bracket <code class="code">&lt;psi|psi&gt;</code>.
The vector <code class="code">psi</code> must always be a <code class="code">ket</code>, otherwise the
function will return <code class="code">false</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c],complex);
(%o1)                                done
(%i2) norm(ket([a,b,c]));
(%o2)       sqrt(c conjugate(c) + b conjugate(b) + a conjugate(a))
(%i3) norm(ket(a,b,c));
(%o3)                           norm(|a, b, c&gt;)
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-magsqr"><span class="category-def">Function: </span><span><strong class="def-name">magsqr</strong> <var class="def-var-arguments">(<code class="code">c</code>)</var><a class="copiable-link" href="#index-magsqr"> &para;</a></span></dt>
<dd><p><code class="code">magsqr</code> returns <code class="code">conjugate(c)*c</code>, the magnitude
squared of a complex number.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b,c,d],complex);
(%o1)                                done
(%i2) A:braket(ket([a,b]),ket([c,d]));
(%o2)                   conjugate(b) d + conjugate(a) c
(%i3) P:magsqr(A);
(%o3) (conjugate(b) d + conjugate(a) c) (b conjugate(d) + a conjugate(c))
</pre></div></div>

<ul class="mini-toc">
<li><a href="#Handling-general-kets-and-bras" accesskey="1">Handling general kets and bras</a></li>
<li><a href="#Spin_002d1_002f2-state-kets-and-associated-operators" accesskey="2">Spin-1/2 state kets and associated operators</a></li>
<li><a href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators" accesskey="3">Pauli matrices and Sz, Sx, Sy operators</a></li>
<li><a href="#SX_002c-SY_002c-SZ-operators-for-any-spin" accesskey="4">SX, SY, SZ operators for any spin</a></li>
<li><a href="#Expectation-value-and-variance" accesskey="5">Expectation value and variance</a></li>
<li><a href="#Angular-momentum-representation-of-kets-and-bras" accesskey="6">Angular momentum representation of kets and bras</a></li>
<li><a href="#Angular-momentum-and-ladder-operators" accesskey="7">Angular momentum and ladder operators</a></li>
</ul>
<div class="subsection-level-extent" id="Handling-general-kets-and-bras">
<h4 class="subsection"><span>1.2.1 Handling general kets and bras<a class="copiable-link" href="#Handling-general-kets-and-bras"> &para;</a></span></h4>

<p>General kets and bras are, as discussed, created without using a list
when giving the arguments. The following examples show how general
kets and bras can be manipulated.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ket(a)+ket(b);
(%o1)                              |b&gt; + |a&gt;
(%i2) braket(bra(a),ket(b));
(%o2)                          kron_delta(a, b)
(%i3) braket(bra(a)+bra(c),ket(b));
(%o3)                 kron_delta(b, c) + kron_delta(a, b)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Spin_002d1_002f2-state-kets-and-associated-operators">
<h4 class="subsection"><span>1.2.2 Spin-1/2 state kets and associated operators<a class="copiable-link" href="#Spin_002d1_002f2-state-kets-and-associated-operators"> &para;</a></span></h4>

<p>Spin-1/2 particles are characterized by a simple 2-dimensional Hilbert
space of states. It is spanned by two vectors. In the <var class="var">z</var>-basis
these vectors are <code class="code">{zp,zm}</code>, and the basis kets in the
<var class="var">z</var>-basis are <code class="code">{xp,xm}</code> and <code class="code">{yp,ym}</code> respectively.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-zp"><span class="category-def">Function: </span><span><strong class="def-name">zp</strong><a class="copiable-link" href="#index-zp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-zm"><span class="category-def">Function: </span><span><strong class="def-name">zm</strong><a class="copiable-link" href="#index-zm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|z-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-xp"><span class="category-def">Function: </span><span><strong class="def-name">xp</strong><a class="copiable-link" href="#index-xp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-xm"><span class="category-def">Function: </span><span><strong class="def-name">xm</strong><a class="copiable-link" href="#index-xm"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|x-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-yp"><span class="category-def">Function: </span><span><strong class="def-name">yp</strong><a class="copiable-link" href="#index-yp"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y+&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ym"><span class="category-def">Function: </span><span><strong class="def-name">ym</strong><a class="copiable-link" href="#index-ym"> &para;</a></span></dt>
<dd><p>Return the <var class="var">|y-&gt;</var> ket in the <var class="var">z</var>-basis.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) zp;
                                     [ 1 ]
(%o1)                                [   ]
                                     [ 0 ]
(%i2) zm;
                                     [ 0 ]
(%o2)                                [   ]
                                     [ 1 ]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) yp;
                                  [    1    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%o1)                             [         ]
                                  [   %i    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%i2) ym;
                                 [     1     ]
                                 [  -------  ]
                                 [  sqrt(2)  ]
(%o2)                            [           ]
                                 [     %i    ]
                                 [ - ------- ]
                                 [   sqrt(2) ]
</pre></div><div class="group"><pre class="example-preformatted">(%i1) braket(xp,zp);
                                       1
(%o1)                               -------
                                    sqrt(2)
</pre></div></div>

<p>Switching bases is done in the following example where a <var class="var">z</var>-basis
ket is constructed and the <var class="var">x</var>-basis ket is computed.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) declare([a,b],complex);
(%o1)                                done
(%i2) psi:ket([a,b]);
                                     [ a ]
(%o2)                                [   ]
                                     [ b ]
(%i3) psi_x:'xp*braket(xp,psi)+'xm*braket(xm,psi);
                    b         a              a         b
(%o3)           (------- + -------) xp + (------- - -------) xm
                 sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators">
<h4 class="subsection"><span>1.2.3 Pauli matrices and Sz, Sx, Sy operators<a class="copiable-link" href="#Pauli-matrices-and-Sz_002c-Sx_002c-Sy-operators"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmax"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmax</code></strong><a class="copiable-link" href="#index-sigmax"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">x</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmay"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmay</code></strong><a class="copiable-link" href="#index-sigmay"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">y</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sigmaz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">sigmaz</code></strong><a class="copiable-link" href="#index-sigmaz"> &para;</a></span></dt>
<dd><p>Returns the Pauli <var class="var">z</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sx"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sx</code></strong><a class="copiable-link" href="#index-Sx"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sx</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sy"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sy</code></strong><a class="copiable-link" href="#index-Sy"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sy</var> matrix.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Sz"><span class="category-def">Function: </span><span><strong class="def-name"><code class="code">Sz</code></strong><a class="copiable-link" href="#index-Sz"> &para;</a></span></dt>
<dd><p>Returns the spin-1/2 <var class="var">Sz</var> matrix.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) sigmay;
                                 [ 0   - %i ]
(%o1)                            [          ]
                                 [ %i   0   ]
(%i2) Sy;
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o2)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-commutator"><span class="category-def">Function: </span><span><strong class="def-name">commutator</strong> <var class="def-var-arguments">(<code class="code">X,Y</code>)</var><a class="copiable-link" href="#index-commutator"> &para;</a></span></dt>
<dd><p>Given two operators <code class="code">X</code> and <code class="code">Y</code>, return the
commutator <code class="code">X . Y - Y . X</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) commutator(Sx,Sy);
                           [        2             ]
                           [ %i hbar              ]
                           [ --------      0      ]
                           [    2                 ]
(%o1)                      [                      ]
                           [                    2 ]
                           [             %i hbar  ]
                           [    0      - -------- ]
                           [                2     ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="SX_002c-SY_002c-SZ-operators-for-any-spin">
<h4 class="subsection"><span>1.2.4 SX, SY, SZ operators for any spin<a class="copiable-link" href="#SX_002c-SY_002c-SZ-operators-for-any-spin"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-SX"><span class="category-def">Function: </span><span><strong class="def-name">SX</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SX"> &para;</a></span></dt>
<dd><p><code class="code">SX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sx</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SY"><span class="category-def">Function: </span><span><strong class="def-name">SY</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SY"> &para;</a></span></dt>
<dd><p><code class="code">SY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sy</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SZ"><span class="category-def">Function: </span><span><strong class="def-name">SZ</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SZ"> &para;</a></span></dt>
<dd><p><code class="code">SZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
spin operator <code class="code">Sz</code>. Shortcuts for spin-1/2 are <code class="code">Sx,Sy,Sz</code>, and
for spin-1 are <code class="code">Sx1,Sy1,Sz1</code>.
</p></dd></dl>

<p>Example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) SY(1/2);
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o1)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
(%i2) SX(1);
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
                         [                           ]
                         [  hbar              hbar   ]
(%o2)                    [ -------     0     ------- ]
                         [ sqrt(2)           sqrt(2) ]
                         [                           ]
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Expectation-value-and-variance">
<h4 class="subsection"><span>1.2.5 Expectation value and variance<a class="copiable-link" href="#Expectation-value-and-variance"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-expect"><span class="category-def">Function: </span><span><strong class="def-name">expect</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-expect"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical expectation value of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">&lt;psi|O|psi&gt;</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ev(expect(Sy,xp+ym),ratsimp);
(%o1)                               - hbar
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-qm_005fvariance"><span class="category-def">Function: </span><span><strong class="def-name">qm_variance</strong> <var class="def-var-arguments">(<code class="code">O,psi</code>)</var><a class="copiable-link" href="#index-qm_005fvariance"> &para;</a></span></dt>
<dd><p>Computes the quantum mechanical variance of the operator <code class="code">O</code>
in state <code class="code">psi</code>, <code class="code">sqrt(&lt;psi|O<sup class="sup">2</sup>|psi&gt; - &lt;psi|O|psi&gt;<sup class="sup">2</sup>)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ev(qm_variance(Sy,xp+ym),ratsimp);
                                    %i hbar
(%o1)                               -------
                                       2
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Angular-momentum-representation-of-kets-and-bras">
<h4 class="subsection"><span>1.2.6 Angular momentum representation of kets and bras<a class="copiable-link" href="#Angular-momentum-representation-of-kets-and-bras"> &para;</a></span></h4>

<p>To create kets and bras in the <var class="var">|j,m&gt;</var> representation you can use
the following functions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fket"><span class="category-def">Function: </span><span><strong class="def-name">jm_ket</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jm_005fket"> &para;</a></span></dt>
<dd><p><code class="code">jm_ket</code> creates the ket <var class="var">|j,m&gt;</var> for total spin <var class="var">j</var>
and <var class="var">z</var>-component <var class="var">m</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fbra"><span class="category-def">Function: </span><span><strong class="def-name">jm_bra</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jm_005fbra"> &para;</a></span></dt>
<dd><p><code class="code">jm_bra</code> creates the bra <var class="var">&lt;j,m|</var> for total spin <var class="var">j</var>
and <var class="var">z</var>-component <var class="var">m</var>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jm_bra(3/2,1/2);
                                        3  1
(%o1)                            jm_bra(-, -)
                                        2  2
(%i2) jm_bra([3/2,1/2]);
                                       [ 3  1 ]
(%o2)                          [jmbra, [ -  - ]]
                                       [ 2  2 ]
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fketp"><span class="category-def">Function: </span><span><strong class="def-name">jm_ketp</strong> <var class="def-var-arguments">(jmket)</var><a class="copiable-link" href="#index-jm_005fketp"> &para;</a></span></dt>
<dd><p><code class="code">jm_ketp</code> checks to see that the ket has the &rsquo;jmket&rsquo; marker.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jm_ketp(jm_ket(j,m));
(%o1)                                false
(%i2) jm_ketp(jm_ket([j,m]));
(%o2)                                true
</pre></div></div>


<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fbrap"><span class="category-def">Function: </span><span><strong class="def-name">jm_brap</strong> <var class="def-var-arguments">(jmbra)</var><a class="copiable-link" href="#index-jm_005fbrap"> &para;</a></span></dt>
<dd><p><code class="code">jm_brap</code> checks to see that the bra has the &rsquo;jmbra&rsquo; marker.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fcheck"><span class="category-def">Function: </span><span><strong class="def-name">jm_check</strong> <var class="def-var-arguments">(<code class="code">j,m</code>)</var><a class="copiable-link" href="#index-jm_005fcheck"> &para;</a></span></dt>
<dd><p><code class="code">jm_check</code> checks to see that <var class="var">m</var> is one of {-j, &hellip;, +j}.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) jm_check(3/2,1/2);
(%o1)                                true
</pre></div></div>


<dl class="first-deffn">
<dt class="deffn" id="index-jm_005fbraket"><span class="category-def">Function: </span><span><strong class="def-name">jm_braket</strong> <var class="def-var-arguments">(<em class="emph">jmbra,jmket</em>)</var><a class="copiable-link" href="#index-jm_005fbraket"> &para;</a></span></dt>
<dd><p><code class="code">jm_braket</code> takes the inner product of the jm-kets.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) K:jm_ket(j1,m1);
(%o1)                           jm_ket(j1, m1)
(%i2) B:jm_bra(j2,m2);
(%o2)                           jm_bra(j2, m2)
(%i3) jm_braket(B,K);
(%o3)                kron_delta(j1, j2) kron_delta(m1, m2)
(%i4) B:jm_bra(j1,m1);
(%o4)                           jm_bra(j1, m1)
(%i5) jm_braket(B,K);
(%o5)                                  1
(%i6) K:jm_ket([j1,m1]);
(%o6)                         [jmket, [ j1  m1 ]]
(%i7) B:jm_bra([j2,m2]);
(%o7)                         [jmbra, [ j2  m2 ]]
(%i8) jm_braket(B,K);
(%o8)                                  0
(%i9) jm_braket(jm_bra(j1,m1)+jm_bra(j3,m3),jm_ket(j2,m2));
(%o9) kron_delta(j2, j3) kron_delta(m2, m3)
                                        + kron_delta(j1, j2) kron_delta(m1, m2)
</pre></div></div>

<dl class="first-deffn">
<dt class="deffn" id="index-JP"><span class="category-def">Function: </span><span><strong class="def-name">JP</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-JP"> &para;</a></span></dt>
<dd><p><code class="code">JP</code> is the <code class="code">J<sub class="sub">+</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jm_ket(j,m)</code> and returns <code class="code">sqrt(j*(j+1)-m*(m+1))*hbar*jm_ket(j,m+1)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-JM"><span class="category-def">Function: </span><span><strong class="def-name">JM</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-JM"> &para;</a></span></dt>
<dd><p><code class="code">JM</code> is the <code class="code">J<sub class="sub">-</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jm_ket(j,m)</code> and returns <code class="code">sqrt(j*(j+1)-m*(m-1))*hbar*jm_ket(j,m-1)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Jsqr"><span class="category-def">Function: </span><span><strong class="def-name">Jsqr</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jsqr"> &para;</a></span></dt>
<dd><p><code class="code">Jsqr</code> is the <code class="code">J<sup class="sup">2</sup></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jm_ket(j,m)</code> and returns <code class="code">(j*(j+1)*hbar<sup class="sup">2</sup>*jm_ket(j,m)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-Jz"><span class="category-def">Function: </span><span><strong class="def-name">Jz</strong> <var class="def-var-arguments">(<em class="emph">jmket</em>)</var><a class="copiable-link" href="#index-Jz"> &para;</a></span></dt>
<dd><p><code class="code">Jz</code> is the <code class="code">J<sub class="sub">z</sub></code> operator. It takes a <code class="code">jmket</code>
<code class="code">jm_ket(j,m)</code> and returns <code class="code">m*hbar*jm_ket(j,m)</code>.
</p></dd></dl>

<p>These functions are illustrated below.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) k:jm_ket([j,m]);
(%o1)                          [jmket, [ j  m ]]
(%i2) JP(k);
(%o2)          hbar jm_ket(j, m + 1) sqrt(j (j + 1) - m (m + 1))
(%i3) JM(k);
(%o3)          hbar jm_ket(j, m - 1) sqrt(j (j + 1) - (m - 1) m)
(%i4) Jsqr(k);
                             2
(%o4)                    hbar  j (j + 1) jm_ket(j, m)
(%i5) Jz(k);
(%o5)                         hbar jm_ket(j, m) m
</pre></div></div>

</div>
<div class="subsection-level-extent" id="Angular-momentum-and-ladder-operators">
<h4 class="subsection"><span>1.2.7 Angular momentum and ladder operators<a class="copiable-link" href="#Angular-momentum-and-ladder-operators"> &para;</a></span></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-SP"><span class="category-def">Function: </span><span><strong class="def-name">SP</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SP"> &para;</a></span></dt>
<dd><p><code class="code">SP</code> is the raising ladder operator <var class="var">S<sub class="sub">+</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SM"><span class="category-def">Function: </span><span><strong class="def-name">SM</strong> <var class="def-var-arguments">(<code class="code">s</code>)</var><a class="copiable-link" href="#index-SM"> &para;</a></span></dt>
<dd><p><code class="code">SM</code> is the raising ladder operator <var class="var">S<sub class="sub">-</sub></var> for spin <code class="code">s</code>.
</p></dd></dl>

<p>Examples of the ladder operators:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) SP(1);
                       [ 0  sqrt(2) hbar       0       ]
                       [                               ]
(%o1)                  [ 0       0        sqrt(2) hbar ]
                       [                               ]
                       [ 0       0             0       ]
(%i2) SM(1);
                       [      0             0        0 ]
                       [                               ]
(%o2)                  [ sqrt(2) hbar       0        0 ]
                       [                               ]
                       [      0        sqrt(2) hbar  0 ]
</pre></div></div>

</div>
</div>
<div class="section-level-extent" id="Rotation-operators">
<h3 class="section"><span>1.3 Rotation operators<a class="copiable-link" href="#Rotation-operators"> &para;</a></span></h3>

<dl class="first-deffn">
<dt class="deffn" id="index-RX"><span class="category-def">Function: </span><span><strong class="def-name">RX</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RX"> &para;</a></span></dt>
<dd><p><code class="code">RX(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rx</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-RY"><span class="category-def">Function: </span><span><strong class="def-name">RY</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RY"> &para;</a></span></dt>
<dd><p><code class="code">RY(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Ry</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-RZ"><span class="category-def">Function: </span><span><strong class="def-name">RZ</strong> <var class="def-var-arguments">(<code class="code">s,t</code>)</var><a class="copiable-link" href="#index-RZ"> &para;</a></span></dt>
<dd><p><code class="code">RZ(s)</code> for spin <code class="code">s</code> returns the matrix representation of the
rotation operator <code class="code">Rz</code> for rotation through angle <code class="code">t</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) RZ(1/2,t);
Proviso: assuming 64*t # 0 
                             [     %i t         ]
                             [   - ----         ]
                             [      2           ]
                             [ %e          0    ]
(%o1)                        [                  ]
                             [             %i t ]
                             [             ---- ]
                             [              2   ]
                             [    0      %e     ]
</pre></div></div>

</div>
<div class="section-level-extent" id="Time_002devolution-operator">
<h3 class="section"><span>1.4 Time-evolution operator<a class="copiable-link" href="#Time_002devolution-operator"> &para;</a></span></h3>

<dl class="first-deffn">
<dt class="deffn" id="index-UU"><span class="category-def">Function: </span><span><strong class="def-name">UU</strong> <var class="def-var-arguments">(<code class="code">H,t</code>)</var><a class="copiable-link" href="#index-UU"> &para;</a></span></dt>
<dd><p><code class="code">UU(H,t)</code> is the time evolution operator for Hamiltonian <code class="code">H</code>. It
is defined as the matrix exponential <code class="code">matrixexp(-%i*H*t/hbar)</code>.
</p></dd></dl>

<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) UU(w*Sy,t);
Proviso: assuming 64*t*w # 0 
                           [     t w         t w  ]
                           [ cos(---)  - sin(---) ]
                           [      2           2   ]
(%o1)                      [                      ]
                           [     t w        t w   ]
                           [ sin(---)   cos(---)  ]
                           [      2          2    ]
</pre></div></div>

</div>
<div class="section-level-extent" id="Tensor-products">
<h3 class="section"><span>1.5 Tensor products<a class="copiable-link" href="#Tensor-products"> &para;</a></span></h3>

<p>Tensor products are represented as lists in Maxima. The ket tensor
product <code class="code">|z+,z+&gt;</code> is represented as <code class="code">[tpket,zp,zp]</code>, and the bra
tensor product <code class="code">&lt;a,b|</code> is represented as <code class="code">[tpbra,a,b]</code> for kets
<code class="code">a</code> and <code class="code">b</code>. The list labels <code class="code">tpket</code> and <code class="code">tpbra</code>
ensure calculations are performed with the correct kind of objects.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-ketprod"><span class="category-def">Function: </span><span><strong class="def-name">ketprod</strong> <var class="def-var-arguments">(<code class="code">k<sub class="sub">1</sub></code>, <code class="code">k<sub class="sub">2</sub></code>, &hellip;)</var><a class="copiable-link" href="#index-ketprod"> &para;</a></span></dt>
<dd><p><code class="code">ketprod</code> produces a tensor product of kets <code class="code">k<sub class="sub">i</sub></code>. All
of the elements must pass the <code class="code">ketp</code> predicate test to be
accepted.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-braprod"><span class="category-def">Function: </span><span><strong class="def-name">braprod</strong> <var class="def-var-arguments">(<code class="code">b<sub class="sub">1</sub></code>, <code class="code">b<sub class="sub">2</sub></code>, &hellip;)</var><a class="copiable-link" href="#index-braprod"> &para;</a></span></dt>
<dd><p><code class="code">braprod</code> produces a tensor product of bras <code class="code">b<sub class="sub">i</sub></code>. All
of the elements must pass the <code class="code">brap</code> predicate test to be
accepted.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-braketprod"><span class="category-def">Function: </span><span><strong class="def-name">braketprod</strong> <var class="def-var-arguments">(<code class="code">B,K</code>)</var><a class="copiable-link" href="#index-braketprod"> &para;</a></span></dt>
<dd><p><code class="code">braketprod</code> takes the inner product of the tensor products
<code class="code">B</code> and <code class="code">K</code>. The tensor products must be of the same length
(number of kets must equal the number of bras).
</p></dd></dl>

<p>Examples below show how to create tensor products and take
the bracket of tensor products.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(%i1) ketprod(zp,zm);
                                     [ 1 ]  [ 0 ]
(%o1)                        ketprod([   ], [   ])
                                     [ 0 ]  [ 1 ]
(%i2) ketprod('zp,'zm);
(%o2)                           ketprod(zp, zm)
</pre></div><div class="group"><pre class="example-preformatted">(%i1) kill(a,b,c,d);
(%o1)                                done
(%i2) declare([a,b,c,d],complex);
(%o2)                                done
(%i3) braprod(bra([a,b]),bra([c,d]));
(%o3)                     braprod([ a  b ], [ c  d ])
(%i4) braprod(dagger(zp),bra([c,d]));
(%o4)                     braprod([ 1  0 ], [ c  d ])
</pre></div><div class="group"><pre class="example-preformatted">(%i1) K:ketprod(zp,zm);
                                     [ 1 ]  [ 0 ]
(%o1)                        ketprod([   ], [   ])
                                     [ 0 ]  [ 1 ]
(%i2) zpb:dagger(zp);
(%o2)                              [ 1  0 ]
(%i3) zmb:dagger(zm);
(%o3)                              [ 0  1 ]
(%i4) B:braprod(zpb,zmb);
(%o4)                     braprod([ 1  0 ], [ 0  1 ])
(%i5) braketprod(K,B);
(%o5)                                false
(%i6) braketprod(B,K);
(%o6)                                false
</pre></div></div>

</div>
</div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="#Introduction-to-package-qm" accesskey="n" rel="next">Introduction to package qm</a>, Previous: <a href="../dir_html/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="../dir_html/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="Function-and-Variable-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
