\input texinfo   @c -*-texinfo-*-

@setfilename qm.info
@settitle Package qm

@ifinfo
@macro var {expr}
<\expr\>
@end macro
@end ifinfo

@dircategory Mathematics/Maxima
@direntry
* Package qm: (maxima) Maxima share package qm for quantum mechanics
@end direntry

@node Top, Introduction to package qm, (dir), (dir)
@top
@menu
* Introduction to package qm::
* Functions and variables for qm::
@end menu
@chapter Package qm

@node Introduction to package qm, Functions and variables for qm, Top, Top
@section Introduction to package qm

Package version: 0.5

The @code{qm} package provides functions and standard definitions
to solve quantum mechanics problems in a finite dimensional Hilbert
space. One can calculate the outcome of Stern-Gerlach experiments using
the built-in definition of the Sx, Sy, and Sz for arbitrary spin,
e.g. @code{s=@{1/2, 1, 3/2, @dots{}@}}. One can create ket vectors
with arbitrary but finite dimension and perform standard computations.
Angular momentum representation of kets is available as well.

With this package it is also possible to create tensor product states
for multiparticle systems and to perform calculations on those systems.

The @code{qm} package was written by E. Majzoub, Univ. of Missouri.
Email: majzoube-at-umsystem.edu

@node Functions and variables for qm, ,Introduction to package qm, Top
@section Functions and Variables for qm

@deffn {Function} cvec (@code{a@sub{1}},@code{a@sub{2}},@dots{})
@code{cvec} creates a @emph{column} vector of arbitrary dimension. The
entries @code{a@sub{i}} can be any Maxima expression.
@end deffn

@example
@group
(%i6) load(qm)$
(%i7) cvec(1,2,3);
                                     [ 1 ]
                                     [   ]
(%o7)                                [ 2 ]
                                     [   ]
                                     [ 3 ]
@end group
@end example

@anchor{rvec}
@deffn {Function} rvec (@code{a@sub{1}},@code{a@sub{2}},@dots{})
@code{rvec} creates a @emph{row} vector of arbitrary dimension. The
entries @code{a@sub{i}} can be any Maxima expression.
@end deffn

@example
@group
(%i8) rvec(1,2,3);
(%o8)                             [ 1  2  3 ]
@end group
@end example

@anchor{ket}
@deffn {Function} ket (@code{c@sub{1}},@code{c@sub{2}},@dots{})
@code{ket} creates a @emph{column} vector of arbitrary dimension. The
entries @code{c@sub{i}} can be any Maxima expression. If the entries
are simple symbols or coefficients of simple functions then they will
be @code{declare}-ed complex. If one is having difficulty with getting
the correct constants declared complex then one is suggested to use
the @code{cvec} and @code{rvec} functions.
@end deffn

@example
@group
(%i10) ket(c1,c2);
                                    [ c1 ]
(%o10)                              [    ]
                                    [ c2 ]
(%i11) facts();
(%o11) [kind(c1, complex), kind(c2, complex)]                                   
@end group
@end example

@anchor{bra}
@deffn {Function} bra (@code{c@sub{1}},@code{c@sub{2}},@dots{})
@code{bra} creates a @emph{row} vector of arbitrary dimension. The
entries @code{c@sub{i}} can be any Maxima expression. If the entries
are simple symbols or coefficients of simple functions then they will
be @code{declare}-ed complex. If one is having difficulty with getting
the correct constants declared complex then one is suggested to use
the @code{cvec} and @code{rvec} functions.
@end deffn

@example
@group
(%i11) bra(c1,c2);
(%o11)                            [ c1  c2 ]
@end group
@end example

@anchor{ketp}
@deffn {Function} ketp (@emph{vector})
@code{ketp} is a predicate function that checks if its input is a ket,
in which case it returns @code{true}, else it returns @code{false}.
@end deffn

@example
@group
(%i3) b: bra(a,b);
(%o3)                              [ a  b ]
(%i4) ketp(b);
(%o4)                                false
@end group
@end example

@anchor{brap}
@deffn {Function} brap (@emph{vector})
@code{brap} is a predicate function that checks if its input is a bra,
in which case it returns @code{true}, else it returns @code{false}.
@end deffn

@example
@group
(%i4) b: bra(a,b);
(%o4)                              [ a  b ]
(%i5) brap(b);
(%o5)                                true
@end group
@end example

@anchor{dag}
@deffn {Function} dag (@emph{vector})
@code{dag} returns the @code{conjugate} @code{transpose} of its input.
@end deffn

@example
@group
(%i13) dag( bra(%i,2) );
                                   [ - %i ]
(%o13)                             [      ]
                                   [  2   ]
@end group
@end example

@anchor{braket}
@deffn {Function} braket (@code{psi,phi})
Given two kets @code{psi} and @code{phi}, @code{braket} returns the
quantum mechanical bracket @code{<psi|phi>}. The vector @code{psi} may be
input as either a @code{ket} or @code{bra}. If it is a @code{ket} it will be
turned into a @code{bra} with the @code{dag} function before the inner
product is taken. The vector @code{phi} must always be a @code{ket}.
@end deffn

@example
@group
(%i7) braket(ket(a,b,c),ket(a,b,c));
(%o7)          c conjugate(c) + b conjugate(b) + a conjugate(a)
@end group
@end example

@anchor{norm}
@deffn {Function} norm (@code{psi})
Given a @code{ket} or @code{bra} @code{psi}, @code{norm} returns the
square root of the quantum mechanical bracket @code{<psi|psi>}.
The vector @code{psi} must always be a @code{ket}, otherwise the
function will return @code{false}.
@end deffn

@example
@group
(%i8) norm(ket(a,b,c));
(%o8)       sqrt(c conjugate(c) + b conjugate(b) + a conjugate(a))
@end group
@end example

@subsection Simple examples

The following additional examples show how to input vectors of various kinds
and to do simple manipulations with them.

@example
@group
(%i2) rvec(a,b,c);
(%o2)                             [ a  b  c ]
(%i3) facts();
(%o3)        [kind(hbar, real), hbar > 0]
(%i4) bra(a,b,c);
(%o4)                             [ a  b  c ]
(%i5) facts();
(%o5) [kind(hbar, real), hbar > 0, kind(a, complex), 
                   kind(b, complex), kind(c, complex)]
(%i6) braket(bra(a,b,c),ket(a,b,c));
                                  2    2    2
(%o6)                            c  + b  + a
(%i7) braket(ket(a,b,c),ket(a,b,c));
(%o7)          c conjugate(c) + b conjugate(b) + a conjugate(a)
@end group
@end example

@subsection Spin-1/2 state kets and associated operators

Spin-1/2 particles are characterized by a simple 2-dimensional Hilbert
space of states. It is spanned by two vectors. In the @var{z}-basis
these vectors are @code{@{zp,zm@}}, and the basis kets in the
@var{z}-basis are @code{@{xp,xm@}} and @code{@{yp,ym@}} respectively.

@anchor{zp}
@deffn {Function} zp,zm,xp,xm,yp,ym
Return the ket of the corresponding vector in the @var{z}-basis.
@end deffn

@example
@group
(%i6) zp;
                                     [ 1 ]
(%o6)                                [   ]
                                     [ 0 ]
(%i7) zm;
                                     [ 0 ]
(%o7)                                [   ]
                                     [ 1 ]
@end group
@group
(%i10) yp;
                                  [    1    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%o10)                            [         ]
                                  [   %i    ]
                                  [ ------- ]
                                  [ sqrt(2) ]
(%i11) ym;
                                 [     1     ]
                                 [  -------  ]
                                 [  sqrt(2)  ]
(%o11)                           [           ]
                                 [     %i    ]
                                 [ - ------- ]
                                 [   sqrt(2) ]
@end group
@group
(%i6) braket(xp,zp);
                                       1
(%o6)                               -------
                                    sqrt(2)
@end group
@end example

Switching bases is done in the following example where a @var{z}-basis
ket is constructed and the @var{x}-basis ket is computed.

@example
@group
(%i3) psi: ket(a,b);
                                     [ a ]
(%o3)                                [   ]
                                     [ b ]
(%i4) psi_x: 'xp*braket(xp,psi) + 'xm*braket(xm,psi);
                    b         a              a         b
(%o4)           (------- + -------) xp + (------- - -------) xm
                 sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
@end group
@end example

@subsection Pauli matrices and Sz, Sx, Sy operators

@deffn {Function} @code{sigmax, sigmay, sigmaz}
Returns the Pauli @var{x,y,z} matrix.
@end deffn

@deffn {Function} @code{Sx, Sy, Sz}
Returns the spin-1/2 @var{Sx,Sy,Sz} matrix.
@end deffn

@example
@group
(%i3) sigmay;
                                 [ 0   - %i ]
(%o3)                            [          ]
                                 [ %i   0   ]
(%i4) Sy;
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o4)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
@end group
@end example

@subsection SX, SY, SZ operators for any spin

@deffn {Function} @code{SX, SY, SZ} (@code{s})
@code{SX(s)} for spin @code{s} returns the matrix representation
of the spin operator @code{Sx}, and similarly for @code{SY(s)}
and @code{SZ(s)}. Shortcuts for spin-1/2 are @code{Sx,Sy,Sz},
and for spin-1 are @code{Sx1,Sy1,Sz1}.
@end deffn

Example:

@example
@group
(%i6) SY(1/2);
                            [            %i hbar ]
                            [    0     - ------- ]
                            [               2    ]
(%o6)                       [                    ]
                            [ %i hbar            ]
                            [ -------      0     ]
                            [    2               ]
(%i7) SX(1);
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
                         [                           ]
                         [  hbar              hbar   ]
(%o7)                    [ -------     0     ------- ]
                         [ sqrt(2)           sqrt(2) ]
                         [                           ]
                         [           hbar            ]
                         [    0     -------     0    ]
                         [          sqrt(2)          ]
@end group
@end example

@subsection Expectation value and variance

@deffn {Function} expect (@code{O,psi})
Computes the quantum mechanical expectation value of the operator @code{O}
in state @code{psi}, @code{<psi|O|psi>}.
@end deffn

@example
@group
(%i5) expect(Sy,xp+ym),ratsimp;
(%o5)                               - hbar
@end group
@end example

@deffn {Function} qm_variance (@code{O,psi})
Computes the quantum mechanical variance of the operator @code{O}
in state @code{psi}, @code{sqrt(<psi|O@sup{2}|psi> - <psi|O|psi>@sup{2})}.
@end deffn

@example
@group
(%i10) qm_variance(Sy,xp+ym),ratsimp;
                                    %i hbar
(%o10)                              -------
                                       2
@end group
@end example

@subsection Angular momentum representation of kets and bras

To create kets and bras in the @var{|j,m>} you can use the following functions.

@deffn {Function} jm_ket (@code{j,m})
@code{jm_ket} creates the ket @var{|j,m>} for total spin @var{j}
and @var{z}-component @var{m}.
@end deffn

@deffn {Function} jm_bra (@code{j,m})
@code{jm_bra} creates the bra @var{<j,m|} for total spin @var{j}
and @var{z}-component @var{m}.
@end deffn

@example
@group
(%i8) jm_bra(3/2,1/2);
                                       [ 3  1 ]
(%o8)                          [jmbra, [ -  - ]]
                                       [ 2  2 ]
@end group
@end example

@deffn {Function} jm_ketp (jmket)
@code{jm_ketp} checks to see that the ket has the 'jmket' marker.
@end deffn

@deffn {Function} jm_brap (jmbra)
@code{jm_brap} checks to see that the bra has the 'jmbra' marker.
@end deffn

@deffn {Function} jm_check (@code{j,m})
@code{jm_check} checks to see that @var{m} is one of @{-j, @dots{}, +j@}.
@end deffn

@deffn {Function} jm_braket (@code{jmbra,jmket})
@code{jm_braket} takes the inner product of the jm-kets.
@end deffn

@example
@group
(%i12) K: jm_ket(zp,zm);
                                      [ [ 1 ] ]
                                      [ [   ] ]
                                      [ [ 0 ] ]
(%o12)                        [jmket, [       ]]
                                      [ [ 0 ] ]
                                      [ [   ] ]
                                      [ [ 1 ] ]
(%i13) B: jm_bra(zp,zm);
                                   [ [ 1 ]  [ 0 ] ]
(%o13)                     [jmbra, [ [   ]  [   ] ]]
                                   [ [ 0 ]  [ 1 ] ]
(%i14) jm_braket(B,K);
(%o14)                                 1
@end group
@end example


@subsection Angular momentum and ladder operators

@deffn {Function} SP (@code{s})
@code{SP} is the raising ladder operator @var{S@sub{+}} for spin @code{s}.
@end deffn

@deffn {Function} SM (@code{s})
@code{SM} is the raising ladder operator @var{S@sub{-}} for spin @code{s}.
@end deffn

Examples of the ladder operators:

@example
@group
(%i4) SP(1);
                       [ 0  sqrt(2) hbar       0       ]
                       [                               ]
(%o4)                  [ 0       0        sqrt(2) hbar ]
                       [                               ]
                       [ 0       0             0       ]
(%i5) SM(1);
                       [      0             0        0 ]
                       [                               ]
(%o5)                  [ sqrt(2) hbar       0        0 ]
                       [                               ]
                       [      0        sqrt(2) hbar  0 ]
@end group
@end example

@section Rotation operators

@deffn {Function} @code{RX, RY, RZ} (@code{s,t})
@code{RX(s)} for spin @code{s} returns the matrix representation
of the rotation operator @code{Rx} for rotation through angle
@code{t}, and similarly for @code{RY(s,t)}
and @code{RZ(s,t)}.
@end deffn

@example
@group
(%i10) RZ(1/2,t);
                             [     %i t         ]
                             [   - ----         ]
                             [      2           ]
                             [ %e          0    ]
(%o10)                       [                  ]
                             [             %i t ]
                             [             ---- ]
                             [              2   ]
                             [    0      %e     ]
@end group
@end example

@section Time-evolution operator

@deffn {Function} UU (@code{H,t})
@code{UU(H,t)} is the time evolution operator for Hamiltonian @code{H}. It
is defined as the matrix exponential @code{matrixexp(-%i*H*t/hbar)}.
@end deffn

@example
@group
(%i12) UU(w*Sy,t);
                           [     t w         t w  ]
                           [ cos(---)  - sin(---) ]
                           [      2           2   ]
(%o12)                     [                      ]
                           [     t w        t w   ]
                           [ sin(---)   cos(---)  ]
                           [      2          2    ]
@end group
@end example

@section Tensor products

Tensor products are represented as lists in Maxima. The ket tensor
product @code{|z+,z+>} is represented as @code{[tpket,zp,zp]}, and the bra
tensor product @code{<a,b|} is represented as @code{[tpbra,a,b]} for kets
@code{a} and @code{b}. The list labels @code{tpket} and @code{tpbra}
ensure calculations are performed with the correct kind of objects.

@deffn {Function} ketprod (@code{k@sub{1}}, @code{k@sub{2}}, @dots{})
@code{ketprod} produces a tensor product of kets @code{k@sub{i}}. All
of the elements must pass the @code{ketp} predicate test to be
accepted.
@end deffn

@deffn {Function} braprod (@code{b@sub{1}}, @code{b@sub{2}}, @dots{})
@code{braprod} produces a tensor product of bras @code{b@sub{i}}. All
of the elements must pass the @code{brap} predicate test to be
accepted.
@end deffn

@deffn {Function} braketprod (@code{B,K})
@code{braketprod} takes the inner product of the tensor products
@code{B} and @code{K}. The tensor products must be of the same length
(number of kets must equal the number of bras).
@end deffn

Examples below show how to create tensor products and take
the bracket of tensor products.

@example
@group
(%i3) ketprod(zp,zm);
                                     [ 1 ]  [ 0 ]
(%o3)                       [tpket, [[   ], [   ]]]
                                     [ 0 ]  [ 1 ]
(%i4) ketprod('zp,'zm);
(%o4)                          [tpket, [zp, zm]]
@end group
@group
(%i4) kill(a,b,c,d)$
(%i5) braprod(bra(a,b),bra(c,d));
(%o5)                    [tpbra, [[ a  b ], [ c  d ]]]
(%i6) braprod(dag(zp),bra(c,d));
(%o6)                    [tpbra, [[ 1  0 ], [ c  d ]]]
@end group

@group
(%i7) zpb: dag(zp);
(%o7)                              [ 1  0 ]
(%i8) zmb: dag(zm);
(%o8)                              [ 0  1 ]
(%i9) K: ketprod('zp,'zm);
(%o9)                          [tpket, [zp, zm]]
(%i10) B: braprod(zpb,zmb);
(%o10)                   [tpbra, [[ 1  0 ], [ 0  1 ]]]
(%i11) B: braprod('zpb,'zmb);
(%o11)                        [tpbra, [zpb, zmb]]
(%i12) braketprod(K,B);
(%o12)                               false
(%i13) braketprod(B,K);
(%o13)                       (zmb . zm) (zpb . zp)

@end group
@end example

@node Function and variable index, , Functions and variables for qm, Top
@appendix Function and variable index
@printindex fn
@printindex vr

@bye
