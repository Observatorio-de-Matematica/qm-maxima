This is qm.info, produced by makeinfo version 7.1 from qm.texi.

INFO-DIR-SECTION Mathematics/Maxima
START-INFO-DIR-ENTRY
* Package qm: (maxima) Maxima share package qm for quantum mechanics
END-INFO-DIR-ENTRY


File: qm.info,  Node: Top,  Next: Introduction to package qm,  Prev: (dir),  Up: (dir)

Package qm
**********

* Menu:

* Introduction to package qm::
* Functions and variables for qm::

1 Package qm
************


File: qm.info,  Node: Introduction to package qm,  Next: Functions and variables for qm,  Prev: Top,  Up: Top

1.1 Introduction to package qm
==============================

Package version: 0.5

   The ‘qm’ package provides functions and standard definitions to solve
quantum mechanics problems in a finite dimensional Hilbert space.  For
example, one can calculate the outcome of Stern-Gerlach experiments
using the built-in definition of the Sx, Sy, and Sz operators for
arbitrary spin, e.g.  ‘s={1/2, 1, 3/2, ...}’.  For spin-1/2 the standard
basis states in the <x>, <y>, and <z>-basis are available as ‘{xp,xm}’,
‘{yp,ym}’, and ‘{zp,zm}’.  One can create general ket vectors with
arbitrary but finite dimension and perform standard computations such as
expectation value, variance, etc.  The angular momentum <|j,m>>
representation of kets is also available.  It is also possible to create
tensor product states for multiparticle systems and to perform
calculations on those systems.

   The ‘qm’ package was written by Eric Majzoub, University of Missouri.
(Email: majzoube-at-umsystem.edu) The package is loaded with:
‘load(qm);’


File: qm.info,  Node: Functions and variables for qm,  Prev: Introduction to package qm,  Up: Top

1.2 Functions and Variables for qm
==================================

 -- Variable: hbar
     Planck's constant divided by ‘2*%pi’.  ‘hbar’ is not given a
     floating point value, but is declared to be a real number greater
     than zero.

 -- Function: ket (c_{1},c_{2},...)
     ‘ket’ creates a _column_ vector of arbitrary finite dimension.  The
     entries ‘c_{i}’ can be any Maxima expression.  The user must
     ‘declare’ any relevant constants to be complex.

     (%i4) declare([c1,c2],complex);
     (%o4)                                done
     (%i5) ket(c1,c2);
                                         [ c1 ]
     (%o5)                               [    ]
                                         [ c2 ]
     (%i6) facts();
     (%o6) [kind(hbar, real), hbar > 0, kind(c1, complex), kind(c2, complex)]

 -- Function: bra (c_{1},c_{2},...)
     ‘bra’ creates a _row_ vector of arbitrary finite dimension.  The
     entries ‘c_{i}’ can be any Maxima expression.  The user must
     ‘declare’ any relevant constants to be complex.

     (%i4) bra(c1,c2);
     (%o4)                             [ c1  c2 ]
     (%i5) facts();
     (%o5)                    [kind(hbar, real), hbar > 0]

 -- Function: ketp (_vector_)
     ‘ketp’ is a predicate function that checks if its input is a ket,
     in which case it returns ‘true’, else it returns ‘false’.

     (%i4) b:bra(a,b);
     (%o4)                              [ a  b ]
     (%i5) ketp(b);
     (%o5)                                false

 -- Function: brap (_vector_)
     ‘brap’ is a predicate function that checks if its input is a bra,
     in which case it returns ‘true’, else it returns ‘false’.

     (%i4) b:bra(a,b);
     (%o4)                              [ a  b ]
     (%i5) brap(b);
     (%o5)                                true

 -- Function: dag (_vector_)
     ‘dag’ is the quantum mechanical _dagger_ function and returns the
     ‘conjugate’ ‘transpose’ of its input.

     (%i4) dag(bra(%i,2));
                                        [ - %i ]
     (%o4)                              [      ]
                                        [  2   ]

 -- Function: braket (psi,phi)
     Given two kets ‘psi’ and ‘phi’, ‘braket’ returns the quantum
     mechanical bracket ‘<psi|phi>’.  The vector ‘psi’ may be input as
     either a ‘ket’ or ‘bra’.  If it is a ‘ket’ it will be turned into a
     ‘bra’ with the ‘dag’ function before the inner product is taken.
     The vector ‘phi’ must always be a ‘ket’.

     (%i4) declare([a,b,c],complex);
     (%o4)                                done
     (%i5) braket(ket(a,b,c),ket(a,b,c));
     (%o5)          c conjugate(c) + b conjugate(b) + a conjugate(a)

 -- Function: norm (psi)
     Given a ‘ket’ or ‘bra’ ‘psi’, ‘norm’ returns the square root of the
     quantum mechanical bracket ‘<psi|psi>’.  The vector ‘psi’ must
     always be a ‘ket’, otherwise the function will return ‘false’.

     (%i4) declare([a,b,c],complex);
     (%o4)                                done
     (%i5) norm(ket(a,b,c));
     (%o5)       sqrt(c conjugate(c) + b conjugate(b) + a conjugate(a))

 -- Function: magsqr (c)
     ‘magsqr’ returns ‘conjugate(c)*c’, the magnitude squared of a
     complex number.

     (%i4) declare([a,b,c,c],complex);
     (%o4)                                done
     (%i5) A:braket(ket(a,b),ket(c,d));
     (%o5)                   conjugate(b) d + conjugate(a) c
     (%i6) P:magsqr(A);
     (%o6)      (b d + a conjugate(c)) (conjugate(b) d + conjugate(a) c)

1.2.1 Spin-1/2 state kets and associated operators
--------------------------------------------------

Spin-1/2 particles are characterized by a simple 2-dimensional Hilbert
space of states.  It is spanned by two vectors.  In the <z>-basis these
vectors are ‘{zp,zm}’, and the basis kets in the <z>-basis are ‘{xp,xm}’
and ‘{yp,ym}’ respectively.

 -- Function: zp
     Return the <|z+>> ket in the <z>-basis.

 -- Function: zm
     Return the <|z->> ket in the <z>-basis.

 -- Function: xp
     Return the <|x+>> ket in the <z>-basis.

 -- Function: xm
     Return the <|x->> ket in the <z>-basis.

 -- Function: yp
     Return the <|y+>> ket in the <z>-basis.

 -- Function: ym
     Return the <|y->> ket in the <z>-basis.

     (%i4) zp;
                                          [ 1 ]
     (%o4)                                [   ]
                                          [ 0 ]
     (%i5) zm;
                                          [ 0 ]
     (%o5)                                [   ]
                                          [ 1 ]
     (%i4) yp;
                                       [    1    ]
                                       [ ------- ]
                                       [ sqrt(2) ]
     (%o4)                             [         ]
                                       [   %i    ]
                                       [ ------- ]
                                       [ sqrt(2) ]
     (%i5) ym;
                                      [     1     ]
                                      [  -------  ]
                                      [  sqrt(2)  ]
     (%o5)                            [           ]
                                      [     %i    ]
                                      [ - ------- ]
                                      [   sqrt(2) ]
     (%i4) braket(xp,zp);
                                            1
     (%o4)                               -------
                                         sqrt(2)

   Switching bases is done in the following example where a <z>-basis
ket is constructed and the <x>-basis ket is computed.

     (%i4) declare([a,b],complex);
     (%o4)                                done
     (%i5) psi:ket(a,b);
                                          [ a ]
     (%o5)                                [   ]
                                          [ b ]
     (%i6) psi_x:'xp*braket(xp,psi)+'xm*braket(xm,psi);
                         b         a              a         b
     (%o6)           (------- + -------) xp + (------- - -------) xm
                      sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)

1.2.2 Pauli matrices and Sz, Sx, Sy operators
---------------------------------------------

 -- Function: sigmax
     Returns the Pauli <x> matrix.

 -- Function: sigmay
     Returns the Pauli <y> matrix.

 -- Function: sigmaz
     Returns the Pauli <z> matrix.

 -- Function: Sx
     Returns the spin-1/2 <Sx> matrix.

 -- Function: Sy
     Returns the spin-1/2 <Sy> matrix.

 -- Function: Sz
     Returns the spin-1/2 <Sz> matrix.

     (%i4) sigmay;
                                      [ 0   - %i ]
     (%o4)                            [          ]
                                      [ %i   0   ]
     (%i5) Sy;
                                 [            %i hbar ]
                                 [    0     - ------- ]
                                 [               2    ]
     (%o5)                       [                    ]
                                 [ %i hbar            ]
                                 [ -------      0     ]
                                 [    2               ]

 -- Function: commutator (X,Y)
     Given two operators ‘X’ and ‘Y’, return the commutator ‘X . Y - Y .
     X’.

     (%i4) commutator(Sx,Sy);
                                [        2             ]
                                [ %i hbar              ]
                                [ --------      0      ]
                                [    2                 ]
     (%o4)                      [                      ]
                                [                    2 ]
                                [             %i hbar  ]
                                [    0      - -------- ]
                                [                2     ]

1.2.3 SX, SY, SZ operators for any spin
---------------------------------------

 -- Function: SX (s)
     ‘SX(s)’ for spin ‘s’ returns the matrix representation of the spin
     operator ‘Sx’.  Shortcuts for spin-1/2 are ‘Sx,Sy,Sz’, and for
     spin-1 are ‘Sx1,Sy1,Sz1’.

 -- Function: SY (s)
     ‘SY(s)’ for spin ‘s’ returns the matrix representation of the spin
     operator ‘Sy’.  Shortcuts for spin-1/2 are ‘Sx,Sy,Sz’, and for
     spin-1 are ‘Sx1,Sy1,Sz1’.

 -- Function: SZ (s)
     ‘SZ(s)’ for spin ‘s’ returns the matrix representation of the spin
     operator ‘Sz’.  Shortcuts for spin-1/2 are ‘Sx,Sy,Sz’, and for
     spin-1 are ‘Sx1,Sy1,Sz1’.

   Example:

     (%i4) SY(1/2);
                                 [            %i hbar ]
                                 [    0     - ------- ]
                                 [               2    ]
     (%o4)                       [                    ]
                                 [ %i hbar            ]
                                 [ -------      0     ]
                                 [    2               ]
     (%i5) SX(1);
                              [           hbar            ]
                              [    0     -------     0    ]
                              [          sqrt(2)          ]
                              [                           ]
                              [  hbar              hbar   ]
     (%o5)                    [ -------     0     ------- ]
                              [ sqrt(2)           sqrt(2) ]
                              [                           ]
                              [           hbar            ]
                              [    0     -------     0    ]
                              [          sqrt(2)          ]

1.2.4 Expectation value and variance
------------------------------------

 -- Function: expect (O,psi)
     Computes the quantum mechanical expectation value of the operator
     ‘O’ in state ‘psi’, ‘<psi|O|psi>’.

     (%i4) ev(expect(Sy,xp+ym),ratsimp);
     (%o4)                               - hbar

 -- Function: qm_variance (O,psi)
     Computes the quantum mechanical variance of the operator ‘O’ in
     state ‘psi’, ‘sqrt(<psi|O^{2}|psi> - <psi|O|psi>^{2})’.

     (%i4) ev(qm_variance(Sy,xp+ym),ratsimp);
                                         %i hbar
     (%o4)                               -------
                                            2

1.2.5 Angular momentum representation of kets and bras
------------------------------------------------------

To create kets and bras in the <|j,m>> representation you can use the
following functions.

 -- Function: jm_ket (j,m)
     ‘jm_ket’ creates the ket <|j,m>> for total spin <j> and
     <z>-component <m>.

 -- Function: jm_bra (j,m)
     ‘jm_bra’ creates the bra <<j,m|> for total spin <j> and
     <z>-component <m>.

     (%i4) jm_bra(3/2,1/2);
                                            [ 3  1 ]
     (%o4)                          [jmbra, [ -  - ]]
                                            [ 2  2 ]

 -- Function: jm_ketp (jmket)
     ‘jm_ketp’ checks to see that the ket has the 'jmket' marker.

 -- Function: jm_brap (jmbra)
     ‘jm_brap’ checks to see that the bra has the 'jmbra' marker.

 -- Function: jm_check (j,m)
     ‘jm_check’ checks to see that <m> is one of {-j, ..., +j}.

 -- Function: jm_braket (jmbra,jmket)
     ‘jm_braket’ takes the inner product of the jm-kets.

     (%i4) K:jm_ket(zp,zm);
                                           [ [ 1 ] ]
                                           [ [   ] ]
                                           [ [ 0 ] ]
     (%o4)                         [jmket, [       ]]
                                           [ [ 0 ] ]
                                           [ [   ] ]
                                           [ [ 1 ] ]
     (%i5) B:jm_bra(zp,zm);
                                        [ [ 1 ]  [ 0 ] ]
     (%o5)                      [jmbra, [ [   ]  [   ] ]]
                                        [ [ 0 ]  [ 1 ] ]
     (%i6) jm_braket(B,K);
     (%o6)                                  1

1.2.6 Angular momentum and ladder operators
-------------------------------------------

 -- Function: SP (s)
     ‘SP’ is the raising ladder operator <S_{+}> for spin ‘s’.

 -- Function: SM (s)
     ‘SM’ is the raising ladder operator <S_{-}> for spin ‘s’.

   Examples of the ladder operators:

     (%i4) SP(1);
                            [ 0  sqrt(2) hbar       0       ]
                            [                               ]
     (%o4)                  [ 0       0        sqrt(2) hbar ]
                            [                               ]
                            [ 0       0             0       ]
     (%i5) SM(1);
                            [      0             0        0 ]
                            [                               ]
     (%o5)                  [ sqrt(2) hbar       0        0 ]
                            [                               ]
                            [      0        sqrt(2) hbar  0 ]

1.3 Rotation operators
======================

 -- Function: RX (s,t)
     ‘RX(s)’ for spin ‘s’ returns the matrix representation of the
     rotation operator ‘Rx’ for rotation through angle ‘t’.

 -- Function: RY (s,t)
     ‘RY(s)’ for spin ‘s’ returns the matrix representation of the
     rotation operator ‘Ry’ for rotation through angle ‘t’.

 -- Function: RZ (s,t)
     ‘RZ(s)’ for spin ‘s’ returns the matrix representation of the
     rotation operator ‘Rz’ for rotation through angle ‘t’.

     (%i4) RZ(1/2,t);
     Proviso: assuming 64*t # 0
                                  [     %i t         ]
                                  [   - ----         ]
                                  [      2           ]
                                  [ %e          0    ]
     (%o4)                        [                  ]
                                  [             %i t ]
                                  [             ---- ]
                                  [              2   ]
                                  [    0      %e     ]

1.4 Time-evolution operator
===========================

 -- Function: UU (H,t)
     ‘UU(H,t)’ is the time evolution operator for Hamiltonian ‘H’.  It
     is defined as the matrix exponential ‘matrixexp(-%i*H*t/hbar)’.

     (%i4) UU(w*Sy,t);
     Proviso: assuming 64*t*w # 0
                                [     t w         t w  ]
                                [ cos(---)  - sin(---) ]
                                [      2           2   ]
     (%o4)                      [                      ]
                                [     t w        t w   ]
                                [ sin(---)   cos(---)  ]
                                [      2          2    ]

1.5 Tensor products
===================

Tensor products are represented as lists in Maxima.  The ket tensor
product ‘|z+,z+>’ is represented as ‘[tpket,zp,zp]’, and the bra tensor
product ‘<a,b|’ is represented as ‘[tpbra,a,b]’ for kets ‘a’ and ‘b’.
The list labels ‘tpket’ and ‘tpbra’ ensure calculations are performed
with the correct kind of objects.

 -- Function: ketprod (k_{1}, k_{2}, ...)
     ‘ketprod’ produces a tensor product of kets ‘k_{i}’.  All of the
     elements must pass the ‘ketp’ predicate test to be accepted.

 -- Function: braprod (b_{1}, b_{2}, ...)
     ‘braprod’ produces a tensor product of bras ‘b_{i}’.  All of the
     elements must pass the ‘brap’ predicate test to be accepted.

 -- Function: braketprod (B,K)
     ‘braketprod’ takes the inner product of the tensor products ‘B’ and
     ‘K’.  The tensor products must be of the same length (number of
     kets must equal the number of bras).

   Examples below show how to create tensor products and take the
bracket of tensor products.

     (%i4) ketprod(zp,zm);
                                          [ 1 ]  [ 0 ]
     (%o4)                       [tpket, [[   ], [   ]]]
                                          [ 0 ]  [ 1 ]
     (%i5) ketprod('zp,'zm);
                                all elements must be kets

     (%o5)                                done
     (%i4) kill(a,b,c,d);
     (%o4)                                done
     (%i5) declare([a,b,c,d],complex);
     (%o5)                                done
     (%i6) braprod(bra(a,b),bra(c,d));
     (%o6)                    [tpbra, [[ a  b ], [ c  d ]]]
     (%i7) braprod(dag(zp),bra(c,d));
     (%o7)                    [tpbra, [[ 1  0 ], [ c  d ]]]
     (%i4) zpb:dag(zp);
     (%o4)                              [ 1  0 ]
     (%i5) zmb:dag(zm);
     (%o5)                              [ 0  1 ]
     (%i6) K:ketprod('zp,'zm);
                                all elements must be kets

     (%o6)                                done
     (%i7) B:braprod(zpb,zmb);
     (%o7)                    [tpbra, [[ 1  0 ], [ 0  1 ]]]
     (%i8) B:braprod('zpb,'zmb);
                                all elements must be bras

     (%o8)                                done
     (%i9) braketprod(K,B);
     (%o9)                                false
     (%i10) braketprod(B,K);
     (%o10)                               false


File: qm.info,  Node: Function and variable index,  Prev: Functions and variables for qm,  Up: Top

Appendix A Function and variable index
**************************************

 [index ]
* Menu:

* bra:                                   Functions and variables for qm.
                                                              (line  25)
* braket:                                Functions and variables for qm.
                                                              (line  62)
* braketprod:                            Functions and variables for qm.
                                                              (line 404)
* brap:                                  Functions and variables for qm.
                                                              (line  44)
* braprod:                               Functions and variables for qm.
                                                              (line 400)
* commutator:                            Functions and variables for qm.
                                                              (line 198)
* dag:                                   Functions and variables for qm.
                                                              (line  53)
* expect:                                Functions and variables for qm.
                                                              (line 257)
* jm_bra:                                Functions and variables for qm.
                                                              (line 283)
* jm_braket:                             Functions and variables for qm.
                                                              (line 301)
* jm_brap:                               Functions and variables for qm.
                                                              (line 295)
* jm_check:                              Functions and variables for qm.
                                                              (line 298)
* jm_ket:                                Functions and variables for qm.
                                                              (line 279)
* jm_ketp:                               Functions and variables for qm.
                                                              (line 292)
* ket:                                   Functions and variables for qm.
                                                              (line  11)
* ketp:                                  Functions and variables for qm.
                                                              (line  35)
* ketprod:                               Functions and variables for qm.
                                                              (line 396)
* magsqr:                                Functions and variables for qm.
                                                              (line  84)
* norm:                                  Functions and variables for qm.
                                                              (line  74)
* qm_variance:                           Functions and variables for qm.
                                                              (line 264)
* RX:                                    Functions and variables for qm.
                                                              (line 346)
* RY:                                    Functions and variables for qm.
                                                              (line 350)
* RZ:                                    Functions and variables for qm.
                                                              (line 354)
* sigmax:                                Functions and variables for qm.
                                                              (line 167)
* sigmay:                                Functions and variables for qm.
                                                              (line 170)
* sigmaz:                                Functions and variables for qm.
                                                              (line 173)
* SM:                                    Functions and variables for qm.
                                                              (line 325)
* SP:                                    Functions and variables for qm.
                                                              (line 322)
* Sx:                                    Functions and variables for qm.
                                                              (line 176)
* SX:                                    Functions and variables for qm.
                                                              (line 216)
* Sy:                                    Functions and variables for qm.
                                                              (line 179)
* SY:                                    Functions and variables for qm.
                                                              (line 221)
* Sz:                                    Functions and variables for qm.
                                                              (line 182)
* SZ:                                    Functions and variables for qm.
                                                              (line 226)
* UU:                                    Functions and variables for qm.
                                                              (line 373)
* xm:                                    Functions and variables for qm.
                                                              (line 112)
* xp:                                    Functions and variables for qm.
                                                              (line 109)
* ym:                                    Functions and variables for qm.
                                                              (line 118)
* yp:                                    Functions and variables for qm.
                                                              (line 115)
* zm:                                    Functions and variables for qm.
                                                              (line 106)
* zp:                                    Functions and variables for qm.
                                                              (line 103)

 [index ]
* Menu:

* hbar:                                  Functions and variables for qm.
                                                                (line 6)



Tag Table:
Node: Top211
Node: Introduction to package qm427
Node: Functions and variables for qm1596
Ref: ket1949
Ref: bra2540
Ref: ketp2931
Ref: brap3249
Ref: dag3566
Ref: braket3897
Ref: norm4499
Node: Function and variable index19064

End Tag Table


Local Variables:
coding: utf-8
End:
